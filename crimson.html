<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Crimson Descent</title>
  <script src="/_sdk/element_sdk.js"></script>
  <style>
    body {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: 'Courier New', monospace;
      background: #0a0a0a;
      color: #fff;
      overflow: hidden;
      height: 100%;
    }

    html {
      height: 100%;
    }

    #game-container {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      background: linear-gradient(135deg, #1a0000 0%, #0a0a0a 100%);
    }

    #ui-top {
      padding: 15px 20px;
      background: rgba(0, 0, 0, 0.8);
      border-bottom: 2px solid #ff0000;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    #game-title {
      font-size: 24px;
      font-weight: bold;
      color: #ff0000;
      text-shadow: 0 0 10px #ff0000;
    }

    #stats {
      display: flex;
      gap: 30px;
      font-size: 16px;
    }

    .stat {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .stat-label {
      color: #888;
    }

    .stat-value {
      color: #fff;
      font-weight: bold;
    }

    #health-bar {
      width: 150px;
      height: 20px;
      background: #300;
      border: 2px solid #ff0000;
      position: relative;
    }

    #health-fill {
      height: 100%;
      background: linear-gradient(90deg, #ff0000 0%, #ff6666 100%);
      transition: width 0.2s;
    }

    #weapon-display {
      color: #ffaa00;
      font-weight: bold;
    }

    #coins-display {
      color: #ffd700;
      font-weight: bold;
    }

    #canvas-wrapper {
      flex: 1;
      position: relative;
      overflow: hidden;
    }

    #game-canvas {
      display: block;
      width: 100%;
      height: 100%;
      image-rendering: crisp-edges;
    }

    #game-over-screen, #victory-screen, #start-screen, #shop-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      gap: 20px;
      z-index: 10;
      overflow-y: auto;
      padding: 20px;
      box-sizing: border-box;
    }

    #start-screen h1 {
      font-size: 48px;
      color: #ff0000;
      text-shadow: 0 0 20px #ff0000;
      margin: 0;
    }

    #start-screen p {
      font-size: 18px;
      color: #aaa;
      max-width: 500px;
      text-align: center;
      line-height: 1.6;
    }

    .controls {
      margin-top: 20px;
      padding: 20px;
      background: rgba(255, 0, 0, 0.1);
      border: 1px solid #ff0000;
      border-radius: 8px;
    }

    .controls h3 {
      margin: 0 0 15px 0;
      color: #ff0000;
    }

    .controls div {
      margin: 8px 0;
      color: #ccc;
    }

    .game-over-title {
      font-size: 64px;
      color: #ff0000;
      text-shadow: 0 0 30px #ff0000;
      margin: 0;
    }

    .victory-title {
      font-size: 64px;
      color: #00ff00;
      text-shadow: 0 0 30px #00ff00;
      margin: 0;
    }

    .final-stats {
      font-size: 24px;
      color: #fff;
      text-align: center;
    }

    .btn {
      padding: 15px 40px;
      font-size: 20px;
      font-family: 'Courier New', monospace;
      background: #ff0000;
      color: #fff;
      border: none;
      cursor: pointer;
      text-transform: uppercase;
      font-weight: bold;
      transition: all 0.2s;
      box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
    }

    .btn:hover {
      background: #ff3333;
      box-shadow: 0 0 30px rgba(255, 0, 0, 0.8);
      transform: scale(1.05);
    }

    .hidden {
      display: none !important;
    }

    #minimap {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 150px;
      height: 150px;
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid #ff0000;
      z-index: 5;
    }

    .shop-item {
      background: rgba(255, 215, 0, 0.1);
      border: 2px solid #ffd700;
      padding: 20px;
      text-align: center;
      border-radius: 8px;
      transition: all 0.2s;
    }

    .shop-item:hover {
      background: rgba(255, 215, 0, 0.2);
      transform: scale(1.05);
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
    }

    .shop-item-icon {
      font-size: 48px;
      margin-bottom: 10px;
    }

    .shop-item-name {
      font-size: 18px;
      color: #fff;
      font-weight: bold;
      margin-bottom: 8px;
    }

    .shop-item-desc {
      font-size: 14px;
      color: #aaa;
      margin-bottom: 12px;
    }

    .shop-item-price {
      font-size: 20px;
      color: #ffd700;
      font-weight: bold;
      margin-bottom: 15px;
    }

    .shop-buy-btn {
      padding: 10px 30px;
      font-size: 16px;
      font-family: 'Courier New', monospace;
      background: #ffd700;
      color: #000;
      border: none;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.2s;
    }

    .shop-buy-btn:hover {
      background: #ffed4e;
      transform: scale(1.1);
    }

    .shop-buy-btn:disabled {
      background: #666;
      color: #333;
      cursor: not-allowed;
    }
  </style>
  <style>@view-transition { navigation: auto; }</style>
  <script src="/_sdk/data_sdk.js" type="text/javascript"></script>
  <script src="https://cdn.tailwindcss.com" type="text/javascript"></script>
 </head>
 <body>
  <div id="game-container">
   <div id="ui-top">
    <div id="game-title">
     CRIMSON DESCENT
    </div>
    <div id="stats">
     <div class="stat"><span class="stat-label">FLOOR:</span> <span class="stat-value" id="floor-display">1</span>
     </div>
     <div class="stat"><span class="stat-label">KILLS:</span> <span class="stat-value" id="kills-display">0</span>
     </div>
     <div class="stat"><span class="stat-label">COINS:</span> <span class="stat-value" id="coins-display">0</span>
     </div>
     <div class="stat"><span class="stat-label">WEAPON:</span> <span class="stat-value" id="weapon-display">Basic Blaster</span>
     </div>
     <div class="stat">
      <div id="health-bar">
       <div id="health-fill"></div>
      </div>
     </div>
    </div>
   </div>
   <div id="canvas-wrapper">
    <canvas id="game-canvas"></canvas>
    <canvas id="minimap"></canvas>
    <div id="start-screen">
     <h1 id="start-title">CRIMSON DESCENT</h1>
     <p>A fast-paced top-down shooter where every floor ends in a brutal boss fight. Find treasure rooms with powerful weapons and collect coins from defeated enemies!</p>
     <div class="controls">
      <h3>CONTROLS</h3>
      <div>
       <strong>WASD</strong> - Move
      </div>
      <div>
       <strong>Mouse</strong> - Aim
      </div>
      <div>
       <strong>Click</strong> - Shoot
      </div>
      <div>
       <strong>Space</strong> - Dash
      </div>
      <div>
       <strong>F</strong> - Punch (Deflects Bullets!)
      </div>
     </div><button class="btn" id="start-btn">START GAME</button>
    </div>
    <div id="game-over-screen" class="hidden">
     <h1 class="game-over-title">TERMINATED</h1>
     <div class="final-stats">
      <div>
       Floor Reached: <span id="final-floor">0</span>
      </div>
      <div>
       Total Kills: <span id="final-kills">0</span>
      </div>
      <div>
       Coins Collected: <span id="final-coins">0</span>
      </div>
     </div><button class="btn" id="restart-btn">TRY AGAIN</button>
    </div>
    <div id="victory-screen" class="hidden">
     <h1 class="victory-title" id="victory-title">FLOOR CLEARED</h1>
     <div class="final-stats">
      <div id="victory-message">
       Moving to Floor <span id="next-floor">2</span>
      </div>
     </div><button class="btn" id="continue-btn">VISIT SHOP</button>
    </div>
    <div id="shop-screen" class="hidden">
     <h1 style="font-size: 48px; color: #ffd700; text-shadow: 0 0 20px #ffd700; margin: 0;">SHOP</h1>
     <div style="font-size: 18px; color: #ffd700; margin-bottom: 20px;">
      COINS: <span id="shop-coins-display">0</span>
     </div>
     <div id="shop-items" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; max-width: 900px; margin-bottom: 20px;"><!-- Items generated dynamically -->
     </div><button class="shop-buy-btn" id="reroll-shop-btn" style="margin-bottom: 20px; padding: 12px 35px; font-size: 18px;">ðŸ”„ REROLL SHOP (ðŸ’° 5)</button> <button class="btn" id="leave-shop-btn">CONTINUE TO NEXT FLOOR</button>
    </div>
   </div>
  </div>
  <script>
    const defaultConfig = {
      game_title: "CRIMSON DESCENT",
      player_name: "HUNTER"
    };

    let config = { ...defaultConfig };

    async function onConfigChange(newConfig) {
      const titleElement = document.getElementById('game-title');
      const startTitleElement = document.getElementById('start-title');
      
      if (titleElement) {
        titleElement.textContent = newConfig.game_title || defaultConfig.game_title;
      }
      if (startTitleElement) {
        startTitleElement.textContent = newConfig.game_title || defaultConfig.game_title;
      }
    }

    function mapToCapabilities(config) {
      return {
        recolorables: [],
        borderables: [],
        fontEditable: undefined,
        fontSizeable: undefined
      };
    }

    function mapToEditPanelValues(config) {
      return new Map([
        ["game_title", config.game_title || defaultConfig.game_title],
        ["player_name", config.player_name || defaultConfig.player_name]
      ]);
    }

    if (window.elementSdk) {
      window.elementSdk.init({
        defaultConfig,
        onConfigChange,
        mapToCapabilities,
        mapToEditPanelValues
      });
    }

    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    const minimap = document.getElementById('minimap');
    const minimapCtx = minimap.getContext('2d');

    function resizeCanvas() {
      const wrapper = document.getElementById('canvas-wrapper');
      canvas.width = wrapper.clientWidth;
      canvas.height = wrapper.clientHeight;
      minimap.width = 150;
      minimap.height = 150;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Game state
    let gameState = 'start';
    let currentFloor = 1;
    let totalKills = 0;
    let totalCoins = 0;
    let player, bullets, enemies, particles, rooms, currentRoom, dungeon, weaponPickup, coins;
    let keys = {};
    let mouse = { x: 0, y: 0 };

    // Konami code tracking
    const konamiCode = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'b', 'a'];
    let konamiProgress = 0;

    // Permanent upgrades
    let damageMultiplier = 1;
    let fireRateMultiplier = 1;
    let speedBoosts = 0;
    let dashBoosts = 0;
    let hasHotshot = false;
    let hasVampire = false;
    let hasSugarRush = false;
    let sugarRushStacks = 0;
    let hasPennyPincher = false;
    let hasMirror = false;
    let mirrorShotCounter = 0;
    let hasBrassKnuckles = false;
    let brassKnuckleStacks = 0;
    let hasKaboom = false;
    let hasNerd = false;
    let hasComeback = false;
    let hasDog = false;
    let dog = null;
    let hasHalo = false;
    let haloRoomCounter = 0;

    const ROOM_WIDTH = 800;
    const ROOM_HEIGHT = 600;
    const PLAYER_SPEED = 4;
    const DASH_SPEED = 15;
    const DASH_DURATION = 10;

    // Room types
    const ROOM_TYPES = {
      START: 'start',
      NORMAL: 'normal',
      BOSS: 'boss',
      TREASURE: 'treasure'
    };

    // Weapon types
    const WEAPONS = {
      BASIC: { name: 'Basic Blaster', cooldown: 8, bullets: 1, spread: 0, damage: 10, speed: 12, size: 4, type: 'normal' },
      AUTOBLASTER: { name: 'Auto Blaster', cooldown: 3, bullets: 1, spread: 0, damage: 7, speed: 14, size: 3, type: 'normal' },
      CANNON: { name: 'Cannon', cooldown: 30, bullets: 1, spread: 0, damage: 50, speed: 8, size: 8, type: 'normal' },
      BAZOOKA: { name: 'Bazooka', cooldown: 15, bullets: 3, spread: 0.3, damage: 15, speed: 10, size: 5, type: 'normal' },
      SNIPER: { name: 'Sniper Rifle', cooldown: 45, bullets: 1, spread: 0, damage: 80, speed: 20, size: 3, type: 'normal' },
      MINIGUN: { name: 'Minigun', cooldown: 2, bullets: 1, spread: 0.15, damage: 6, speed: 14, size: 3, type: 'normal' },
      SHOTGUN: { name: 'Shotgun', cooldown: 25, bullets: 8, spread: 0.4, damage: 12, speed: 11, size: 3, type: 'normal' },
      FLAMETHROWER: { name: 'Flamethrower', cooldown: 2, bullets: 5, spread: 0.5, damage: 4, speed: 9, size: 5, type: 'flame' },
      ROCKET: { name: 'Rocket Launcher', cooldown: 40, bullets: 1, spread: 0, damage: 60, speed: 10, size: 7, type: 'rocket' },
      TASER: { name: 'Taser', cooldown: 20, bullets: 1, spread: 0, damage: 8, speed: 15, size: 4, type: 'taser', stunDuration: 120 },
      BOUNCER: { name: 'Bouncer', cooldown: 12, bullets: 1, spread: 0, damage: 18, speed: 13, size: 5, type: 'bouncer', maxBounces: 3 },
      HOMING: { name: 'Homing Missiles', cooldown: 18, bullets: 1, spread: 0, damage: 22, speed: 8, size: 6, type: 'homing', homingStrength: 0.15 }
    };

    class Dog {
      constructor() {
        this.x = 0;
        this.y = 0;
        this.size = 10;
        this.attackCooldown = 0;
        this.attackTime = 0;
        this.targetEnemy = null;
        this.offsetAngle = 0;
      }

      update() {
        if (this.attackCooldown > 0) {
          this.attackCooldown--;
        }
        if (this.attackTime > 0) {
          this.attackTime--;
        }

        // Find nearest enemy
        let nearestEnemy = null;
        let nearestDist = Infinity;
        enemies.forEach(enemy => {
          const dx = enemy.x - player.x;
          const dy = enemy.y - player.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < nearestDist) {
            nearestDist = dist;
            nearestEnemy = enemy;
          }
        });

        if (nearestEnemy && nearestDist < 250) {
          // Chase enemy
          const dx = nearestEnemy.x - this.x;
          const dy = nearestEnemy.y - this.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist > 30) {
            this.x += (dx / dist) * 5;
            this.y += (dy / dist) * 5;
          }

          // Attack when close
          if (dist < 30 && this.attackCooldown === 0) {
            this.attackTime = 10;
            this.targetEnemy = nearestEnemy;
            this.attackCooldown = 30;
            
            const dogDamage = Math.floor(15 * damageMultiplier);
            if (nearestEnemy.takeDamage(dogDamage)) {
              const enemyIndex = enemies.indexOf(nearestEnemy);
              if (enemyIndex !== -1) {
                // Spawn particles
                for (let i = 0; i < 15; i++) {
                  particles.push(new Particle(nearestEnemy.x, nearestEnemy.y, '#ff3333'));
                }
                
                // Drop coins
                const coinCount = Math.ceil(nearestEnemy.coinValue * (0.5 + Math.random() * 0.5));
                const coinMultiplier = hasPennyPincher ? 2 : 1;
                for (let i = 0; i < coinCount * coinMultiplier; i++) {
                  coins.push(new Coin(nearestEnemy.x, nearestEnemy.y, 1));
                }
                
                enemies.splice(enemyIndex, 1);
                totalKills++;
                updateUI();
              }
            }
          }
        } else {
          // Follow player
          this.offsetAngle += 0.05;
          const orbitDist = 40;
          const targetX = player.x + Math.cos(this.offsetAngle) * orbitDist;
          const targetY = player.y + Math.sin(this.offsetAngle) * orbitDist;
          
          const dx = targetX - this.x;
          const dy = targetY - this.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist > 5) {
            this.x += (dx / dist) * 4;
            this.y += (dy / dist) * 4;
          }
        }

        // Keep in bounds
        this.x = Math.max(this.size + 10, Math.min(ROOM_WIDTH - this.size - 10, this.x));
        this.y = Math.max(this.size + 10, Math.min(ROOM_HEIGHT - this.size - 10, this.y));
      }

      draw() {
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#ffaa00';
        
        // Dog body
        ctx.fillStyle = '#8B4513';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        
        // Dog ears
        ctx.fillStyle = '#654321';
        ctx.beginPath();
        ctx.arc(this.x - 7, this.y - 7, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(this.x + 7, this.y - 7, 5, 0, Math.PI * 2);
        ctx.fill();
        
        // Dog snout
        ctx.fillStyle = '#A0522D';
        ctx.beginPath();
        ctx.arc(this.x, this.y + 5, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // Dog eyes
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.arc(this.x - 4, this.y - 2, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(this.x + 4, this.y - 2, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Attack visual
        if (this.attackTime > 0 && this.targetEnemy) {
          ctx.strokeStyle = '#ff0000';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(this.x, this.y);
          ctx.lineTo(this.targetEnemy.x, this.targetEnemy.y);
          ctx.stroke();
          
          ctx.fillStyle = '#ff0000';
          ctx.beginPath();
          ctx.arc(this.targetEnemy.x, this.targetEnemy.y, 15, 0, Math.PI * 2);
          ctx.globalAlpha = 0.3;
          ctx.fill();
          ctx.globalAlpha = 1;
        }
        
        ctx.shadowBlur = 0;
      }
    }

    class Player {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = 15;
        this.health = 100;
        this.maxHealth = 100;
        this.speed = PLAYER_SPEED + (speedBoosts * 0.6);
        this.dashCooldown = 0;
        this.dashTime = 0;
        this.shootCooldown = 0;
        this.weapon = WEAPONS.BASIC;
        this.momentum = 0;
        this.maxMomentum = 2.5;
        this.momentumBuildRate = 0.05;
        this.momentumDecayRate = 0.15;
        this.punchCooldown = 0;
        this.punchTime = 0;
        this.punchAngle = 0;
        this.invincibilityTime = 0;
      }

      update() {
        if (this.dashTime > 0) {
          this.dashTime--;
        }
        if (this.dashCooldown > 0) {
          this.dashCooldown--;
        }
        if (this.shootCooldown > 0) {
          this.shootCooldown--;
        }
        if (this.punchTime > 0) {
          this.punchTime--;
        }
        if (this.punchCooldown > 0) {
          this.punchCooldown--;
        }
        if (this.invincibilityTime > 0) {
          this.invincibilityTime--;
        }

        const isMoving = keys['w'] || keys['W'] || keys['s'] || keys['S'] || keys['a'] || keys['A'] || keys['d'] || keys['D'];
        
        if (isMoving) {
          this.momentum = Math.min(this.momentum + this.momentumBuildRate, this.maxMomentum);
        } else {
          this.momentum = Math.max(this.momentum - this.momentumDecayRate, 0);
        }

        const baseSpeed = this.dashTime > 0 ? DASH_SPEED : this.speed;
        const sugarRushBonus = hasSugarRush ? (sugarRushStacks * 0.3) : 0;
        const comebackBonus = (hasComeback && this.health / this.maxHealth < 0.25) ? (baseSpeed * 1.0) : 0;
        const speed = baseSpeed + (baseSpeed * this.momentum * 0.4) + sugarRushBonus + comebackBonus;
        
        if (keys['w'] || keys['W']) this.y -= speed;
        if (keys['s'] || keys['S']) this.y += speed;
        if (keys['a'] || keys['A']) this.x -= speed;
        if (keys['d'] || keys['D']) this.x += speed;

        this.x = Math.max(20, Math.min(ROOM_WIDTH - 20, this.x));
        this.y = Math.max(20, Math.min(ROOM_HEIGHT - 20, this.y));
      }

      dash() {
        let maxDashCooldown = Math.max(60 - (dashBoosts * 10), 20);
        // Comeback: 50% faster dash cooldown when below 25% HP
        if (hasComeback && this.health / this.maxHealth < 0.25) {
          maxDashCooldown = Math.floor(maxDashCooldown * 0.5);
        }
        if (this.dashCooldown === 0) {
          this.dashTime = DASH_DURATION;
          this.dashCooldown = maxDashCooldown;
        }
      }

      punch(targetX, targetY) {
        if (this.punchCooldown === 0) {
          this.punchTime = 15;
          this.punchCooldown = 40;
          this.punchAngle = Math.atan2(targetY - this.y, targetX - this.x);
        }
      }

      shoot(targetX, targetY) {
        if (this.shootCooldown === 0) {
          const baseAngle = Math.atan2(targetY - this.y, targetX - this.x);
          
          // Mirror passive - every 10th shot fires in all 8 directions
          if (hasMirror) {
            mirrorShotCounter++;
            if (mirrorShotCounter >= 10) {
              mirrorShotCounter = 0;
              // Fire in all 8 directions
              for (let dir = 0; dir < 8; dir++) {
                const angle = (Math.PI * 2 / 8) * dir;
                bullets.push(new Bullet(this.x, this.y, angle, true, this.weapon));
              }
              
              // Mirror visual effect
              particles.push(new ShockwaveParticle(this.x, this.y, '#ffffff', 20));
              for (let i = 0; i < 20; i++) {
                particles.push(new Particle(this.x, this.y, '#ffffff'));
              }
            } else {
              // Normal shot
              for (let i = 0; i < this.weapon.bullets; i++) {
                let angle = baseAngle;
                if (this.weapon.bullets > 1) {
                  angle += (i - (this.weapon.bullets - 1) / 2) * this.weapon.spread;
                }
                bullets.push(new Bullet(this.x, this.y, angle, true, this.weapon));
              }
            }
          } else {
            // Normal shot without Mirror
            for (let i = 0; i < this.weapon.bullets; i++) {
              let angle = baseAngle;
              if (this.weapon.bullets > 1) {
                angle += (i - (this.weapon.bullets - 1) / 2) * this.weapon.spread;
              }
              bullets.push(new Bullet(this.x, this.y, angle, true, this.weapon));
            }
          }
          
          let cooldown = Math.floor(this.weapon.cooldown * fireRateMultiplier);
          // Comeback: 50% faster fire rate when below 25% HP
          if (hasComeback && this.health / this.maxHealth < 0.25) {
            cooldown = Math.floor(cooldown * 0.5);
          }
          this.shootCooldown = cooldown;
        }
      }

      takeDamage(amount) {
        this.health -= amount;
        if (this.health <= 0) {
          gameState = 'gameOver';
          showGameOver();
        }
      }

      setWeapon(weaponType) {
        this.weapon = weaponType;
        document.getElementById('weapon-display').textContent = weaponType.name;
      }

      draw() {
        // Invincibility shield effect
        if (this.invincibilityTime > 0) {
          const pulseIntensity = Math.sin(Date.now() / 50) * 0.3 + 0.7;
          ctx.shadowBlur = 30;
          ctx.shadowColor = '#00ffff';
          ctx.strokeStyle = '#00ffff';
          ctx.lineWidth = 4;
          ctx.globalAlpha = pulseIntensity;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size + 15, 0, Math.PI * 2);
          ctx.stroke();
          
          // Inner shield ring
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size + 10, 0, Math.PI * 2);
          ctx.stroke();
          
          ctx.globalAlpha = 1;
          ctx.shadowBlur = 0;
          
          // Shield sparkles
          for (let i = 0; i < 8; i++) {
            const angle = (Math.PI * 2 / 8) * i + (Date.now() / 100);
            const dist = this.size + 12;
            const sparkleX = this.x + Math.cos(angle) * dist;
            const sparkleY = this.y + Math.sin(angle) * dist;
            
            ctx.fillStyle = '#00ffff';
            ctx.beginPath();
            ctx.arc(sparkleX, sparkleY, 3, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        
        // Comeback rainbow effect when below 25% HP
        if (hasComeback && this.health / this.maxHealth < 0.25) {
          const time = Date.now() / 100;
          for (let i = 0; i < 12; i++) {
            const angle = (Math.PI * 2 / 12) * i + time;
            const dist = this.size + 12;
            const x = this.x + Math.cos(angle) * dist;
            const y = this.y + Math.sin(angle) * dist;
            
            const hue = (i * 30 + time * 50) % 360;
            const color = `hsl(${hue}, 100%, 60%)`;
            
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, 8);
            gradient.addColorStop(0, color);
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, 8, 0, Math.PI * 2);
            ctx.fill();
          }
          
          // Rainbow trail particles
          if (Math.random() < 0.3) {
            const hue = (Date.now() / 10) % 360;
            const color = `hsl(${hue}, 100%, 60%)`;
            particles.push(new Particle(this.x + Math.random() * 20 - 10, this.y + Math.random() * 20 - 10, color));
          }
        }
        
        // Hotshot fire aura
        if (hasHotshot) {
          for (let i = 0; i < 8; i++) {
            const angle = (Math.PI * 2 / 8) * i + (Date.now() / 150);
            const flameX = this.x + Math.cos(angle) * (this.size + 8);
            const flameY = this.y + Math.sin(angle) * (this.size + 8) - Math.abs(Math.sin(Date.now() / 100 + i)) * 10;
            
            const gradient = ctx.createRadialGradient(flameX, flameY, 0, flameX, flameY, 10);
            gradient.addColorStop(0, '#ffff00');
            gradient.addColorStop(0.5, '#ff6600');
            gradient.addColorStop(1, 'rgba(255, 102, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(flameX, flameY, 10, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        const glowIntensity = this.dashTime > 0 ? 20 : 10;
        ctx.shadowBlur = glowIntensity;
        
        // Comeback rainbow appearance when below 25% HP
        if (hasComeback && this.health / this.maxHealth < 0.25) {
          const hue = (Date.now() / 10) % 360;
          const color = `hsl(${hue}, 100%, 60%)`;
          ctx.shadowColor = color;
          ctx.fillStyle = color;
        }
        // Vampire appearance
        else if (hasVampire) {
          ctx.shadowColor = '#ff0066';
          ctx.fillStyle = this.dashTime > 0 ? '#cc0055' : '#990044';
        } else {
          ctx.shadowColor = '#ff0000';
          ctx.fillStyle = this.dashTime > 0 ? '#ff6666' : '#ff0000';
        }
        
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Vampire fangs
        if (hasVampire) {
          ctx.fillStyle = '#ffffff';
          ctx.beginPath();
          ctx.arc(this.x - 5, this.y + 3, 3, 0, Math.PI * 2);
          ctx.arc(this.x + 5, this.y + 3, 3, 0, Math.PI * 2);
          ctx.fill();
        }

        // Sugar Rush lollipop
        if (hasSugarRush) {
          const lollipopAngle = Math.PI * 0.75;
          const lollipopX = this.x + Math.cos(lollipopAngle) * 25;
          const lollipopY = this.y + Math.sin(lollipopAngle) * 25;
          
          // Lollipop stick
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(this.x, this.y);
          ctx.lineTo(lollipopX, lollipopY);
          ctx.stroke();
          
          // Lollipop candy (spiral pattern)
          const candyGradient = ctx.createRadialGradient(lollipopX, lollipopY, 0, lollipopX, lollipopY, 10);
          candyGradient.addColorStop(0, '#ff69b4');
          candyGradient.addColorStop(0.5, '#ff1493');
          candyGradient.addColorStop(1, '#ff69b4');
          ctx.fillStyle = candyGradient;
          ctx.beginPath();
          ctx.arc(lollipopX, lollipopY, 10, 0, Math.PI * 2);
          ctx.fill();
          
          // Spiral on candy
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(lollipopX, lollipopY, 6, 0, Math.PI);
          ctx.stroke();
          
          // Speed stacks indicator
          if (sugarRushStacks > 0) {
            ctx.fillStyle = '#ffff00';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`x${sugarRushStacks}`, lollipopX, lollipopY - 18);
          }
        }

        // Penny Pincher top hat
        if (hasPennyPincher) {
          const hatX = this.x;
          const hatY = this.y - this.size - 15;
          
          ctx.shadowBlur = 10;
          ctx.shadowColor = '#000000';
          
          // Hat top cylinder
          ctx.fillStyle = '#000000';
          ctx.fillRect(hatX - 8, hatY - 15, 16, 15);
          
          // Hat brim
          ctx.fillStyle = '#000000';
          ctx.beginPath();
          ctx.ellipse(hatX, hatY + 1, 15, 4, 0, 0, Math.PI * 2);
          ctx.fill();
          
          // Hat band (gold)
          ctx.fillStyle = '#ffd700';
          ctx.fillRect(hatX - 8, hatY - 3, 16, 3);
          
          ctx.shadowBlur = 0;
        }

        // Mirror passive indicator
        if (hasMirror) {
          const mirrorX = this.x + 30;
          const mirrorY = this.y - 15;
          
          // Mirror frame
          ctx.shadowBlur = 15;
          ctx.shadowColor = '#ffffff';
          ctx.strokeStyle = '#cccccc';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(mirrorX, mirrorY, 12, 0, Math.PI * 2);
          ctx.stroke();
          
          // Mirror surface (reflective)
          const mirrorGradient = ctx.createRadialGradient(mirrorX - 3, mirrorY - 3, 0, mirrorX, mirrorY, 10);
          mirrorGradient.addColorStop(0, '#ffffff');
          mirrorGradient.addColorStop(0.5, '#aaaaff');
          mirrorGradient.addColorStop(1, '#666666');
          ctx.fillStyle = mirrorGradient;
          ctx.beginPath();
          ctx.arc(mirrorX, mirrorY, 9, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.shadowBlur = 0;
          
          // Shot counter
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 12px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(`${mirrorShotCounter}/10`, mirrorX, mirrorY + 25);
        }

        // Kaboom fuse visual
        if (hasKaboom) {
          const fuseX = this.x;
          const fuseY = this.y - this.size - 10;
          
          // Fuse stick
          ctx.strokeStyle = '#654321';
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.moveTo(this.x, this.y - this.size);
          ctx.lineTo(fuseX, fuseY - 15);
          ctx.stroke();
          
          // Fuse spark (animated)
          const sparkOffset = Math.sin(Date.now() / 100) * 3;
          ctx.shadowBlur = 20;
          ctx.shadowColor = '#ff6600';
          ctx.fillStyle = '#ff6600';
          ctx.beginPath();
          ctx.arc(fuseX + sparkOffset, fuseY - 15, 5, 0, Math.PI * 2);
          ctx.fill();
          
          // Spark particles
          ctx.fillStyle = '#ffaa00';
          ctx.beginPath();
          ctx.arc(fuseX + sparkOffset - 2, fuseY - 18, 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(fuseX + sparkOffset + 2, fuseY - 18, 2, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.shadowBlur = 0;
        }

        // Nerd glasses visual
        if (hasNerd) {
          const glassesY = this.y - 3;
          
          // Glasses frames
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 3;
          ctx.fillStyle = 'rgba(200, 230, 255, 0.3)';
          
          // Left lens
          ctx.beginPath();
          ctx.arc(this.x - 6, glassesY, 5, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          
          // Right lens
          ctx.beginPath();
          ctx.arc(this.x + 6, glassesY, 5, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          
          // Bridge
          ctx.beginPath();
          ctx.moveTo(this.x - 1, glassesY);
          ctx.lineTo(this.x + 1, glassesY);
          ctx.stroke();
          
          // Lens reflection
          ctx.fillStyle = '#ffffff';
          ctx.globalAlpha = 0.6;
          ctx.beginPath();
          ctx.arc(this.x - 7, glassesY - 2, 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(this.x + 5, glassesY - 2, 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
        }

        // Halo visual
        if (hasHalo) {
          const haloY = this.y - this.size - 20;
          
          ctx.shadowBlur = 25;
          ctx.shadowColor = '#ffff00';
          
          // Golden halo ring
          ctx.strokeStyle = '#ffff00';
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.ellipse(this.x, haloY, 18, 6, 0, 0, Math.PI * 2);
          ctx.stroke();
          
          // Inner glow
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 2;
          ctx.globalAlpha = 0.6;
          ctx.beginPath();
          ctx.ellipse(this.x, haloY, 15, 5, 0, 0, Math.PI * 2);
          ctx.stroke();
          ctx.globalAlpha = 1;
          
          // Sparkles around halo
          const sparkleCount = 6;
          for (let i = 0; i < sparkleCount; i++) {
            const angle = (Math.PI * 2 / sparkleCount) * i + (Date.now() / 500);
            const sparkleX = this.x + Math.cos(angle) * 22;
            const sparkleY = haloY + Math.sin(angle) * 8;
            
            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            ctx.arc(sparkleX, sparkleY, 2, 0, Math.PI * 2);
            ctx.fill();
          }
          
          ctx.shadowBlur = 0;
        }

        // Brass Knuckles visual
        if (hasBrassKnuckles) {
          const knuckleX = this.x - 25;
          const knuckleY = this.y + 10;
          
          // Brass knuckles on fist
          ctx.shadowBlur = 10;
          ctx.shadowColor = '#ffaa00';
          ctx.fillStyle = '#cc8800';
          ctx.fillRect(knuckleX - 8, knuckleY - 6, 16, 12);
          
          // Knuckle spikes
          ctx.fillStyle = '#ffcc00';
          for (let i = 0; i < 4; i++) {
            ctx.beginPath();
            ctx.moveTo(knuckleX - 6 + i * 4, knuckleY - 6);
            ctx.lineTo(knuckleX - 4 + i * 4, knuckleY - 10);
            ctx.lineTo(knuckleX - 2 + i * 4, knuckleY - 6);
            ctx.closePath();
            ctx.fill();
          }
          
          ctx.shadowBlur = 0;
          
          // Damage stack counter
          if (brassKnuckleStacks > 0) {
            ctx.fillStyle = '#ff0000';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`+${brassKnuckleStacks * 10}%`, knuckleX, knuckleY + 25);
          }
        }

        if (this.punchTime > 0) {
          const punchProgress = 1 - (this.punchTime / 15);
          const punchDistance = 40 * Math.sin(punchProgress * Math.PI);
          const punchX = this.x + Math.cos(this.punchAngle) * punchDistance;
          const punchY = this.y + Math.sin(this.punchAngle) * punchDistance;
          
          ctx.shadowBlur = 20;
          ctx.shadowColor = '#00ffff';
          ctx.fillStyle = '#00ffff';
          ctx.globalAlpha = 0.8;
          ctx.beginPath();
          ctx.arc(punchX, punchY, 12, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.strokeStyle = '#00ffff';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(this.x, this.y, 30 + punchProgress * 20, this.punchAngle - 0.5, this.punchAngle + 0.5);
          ctx.stroke();
          
          ctx.globalAlpha = 1;
          ctx.shadowBlur = 0;
        }

        const angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x + Math.cos(angle) * 25, this.y + Math.sin(angle) * 25);
        ctx.stroke();
      }
    }

    class Bullet {
      constructor(x, y, angle, isPlayer, weapon) {
        this.x = x;
        this.y = y;
        this.vx = Math.cos(angle) * weapon.speed;
        this.vy = Math.sin(angle) * weapon.speed;
        this.size = weapon.size;
        this.isPlayer = isPlayer;
        this.lifetime = weapon.type === 'flame' ? 35 : 100;
        this.damage = Math.floor(weapon.damage * damageMultiplier);
        this.type = weapon.type || 'normal';
        this.angle = angle;
        this.trailParticles = [];
        this.weapon = weapon;
        this.bouncesLeft = weapon.maxBounces || 0;
        this.lastHitEnemy = null;
        this.homingStrength = weapon.homingStrength || 0;
      }

      update() {
        // Homing missile tracking
        if (this.type === 'homing' && this.isPlayer && enemies.length > 0) {
          // Find nearest enemy
          let nearestEnemy = null;
          let nearestDist = Infinity;
          
          enemies.forEach(enemy => {
            const dx = enemy.x - this.x;
            const dy = enemy.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < nearestDist) {
              nearestDist = dist;
              nearestEnemy = enemy;
            }
          });
          
          // Steer towards nearest enemy
          if (nearestEnemy && nearestDist < 400) {
            const targetAngle = Math.atan2(nearestEnemy.y - this.y, nearestEnemy.x - this.x);
            const currentAngle = Math.atan2(this.vy, this.vx);
            
            let angleDiff = targetAngle - currentAngle;
            // Normalize angle difference
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
            
            // Apply steering
            const newAngle = currentAngle + angleDiff * this.homingStrength;
            const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
            this.vx = Math.cos(newAngle) * speed;
            this.vy = Math.sin(newAngle) * speed;
            this.angle = newAngle;
          }
        }
        
        this.x += this.vx;
        this.y += this.vy;
        
        // Flame bullets slow down and fade
        if (this.type === 'flame') {
          this.vx *= 0.96;
          this.vy *= 0.96;
          this.size *= 0.98;
          
          // Spawn fire particles
          if (Math.random() < 0.6) {
            particles.push(new Particle(this.x, this.y, '#ff6600'));
          }
        }
        
        // Rocket trail
        if (this.type === 'rocket') {
          particles.push(new Particle(this.x, this.y, '#ffaa00'));
          if (Math.random() < 0.3) {
            particles.push(new Particle(this.x, this.y, '#666666'));
          }
        }
        
        // Homing missile trail
        if (this.type === 'homing') {
          particles.push(new Particle(this.x, this.y, '#ff00ff'));
          if (Math.random() < 0.4) {
            particles.push(new Particle(this.x, this.y, '#ffaaff'));
          }
        }
        
        // Bouncer trail
        if (this.type === 'bouncer') {
          if (Math.random() < 0.3) {
            particles.push(new Particle(this.x, this.y, '#00ffaa'));
          }
        }
        
        // Apply Comeback damage bonus if player is below 25% HP
        if (this.isPlayer && hasComeback && player.health / player.maxHealth < 0.25) {
          this.damage = Math.floor((this.weapon.damage * damageMultiplier) * 1.5);
        }
        
        this.lifetime--;
        
        // Sugar Rush: reset stacks on bullet miss
        if (this.isPlayer && this.lifetime <= 0 && hasSugarRush) {
          sugarRushStacks = 0;
        }
        
        return this.lifetime > 0 && this.x > 0 && this.x < ROOM_WIDTH && this.y > 0 && this.y < ROOM_HEIGHT;
      }

      draw() {
        if (this.type === 'homing') {
          ctx.shadowBlur = 20;
          ctx.shadowColor = '#ff00ff';
          
          // Missile body
          ctx.fillStyle = '#aa00aa';
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.rotate(this.angle);
          ctx.fillRect(-this.size, -this.size * 0.4, this.size * 1.8, this.size * 0.8);
          
          // Missile tip (glowing)
          const gradient = ctx.createRadialGradient(this.size * 1.8, 0, 0, this.size * 1.8, 0, this.size);
          gradient.addColorStop(0, '#ff00ff');
          gradient.addColorStop(1, '#ff66ff');
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.moveTo(this.size * 1.8, 0);
          ctx.lineTo(this.size, -this.size * 0.4);
          ctx.lineTo(this.size, this.size * 0.4);
          ctx.closePath();
          ctx.fill();
          
          // Fins
          ctx.fillStyle = '#ff00ff';
          ctx.beginPath();
          ctx.moveTo(-this.size, -this.size * 0.4);
          ctx.lineTo(-this.size * 1.3, -this.size * 0.7);
          ctx.lineTo(-this.size * 0.8, -this.size * 0.4);
          ctx.closePath();
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(-this.size, this.size * 0.4);
          ctx.lineTo(-this.size * 1.3, this.size * 0.7);
          ctx.lineTo(-this.size * 0.8, this.size * 0.4);
          ctx.closePath();
          ctx.fill();
          
          ctx.restore();
          ctx.shadowBlur = 0;
        } else if (this.type === 'bouncer') {
          ctx.shadowBlur = 15;
          ctx.shadowColor = '#00ffaa';
          
          // Spinning bouncer ball
          const spinAngle = Date.now() / 50;
          ctx.fillStyle = '#00ffaa';
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fill();
          
          // Energy rings
          for (let i = 0; i < 3; i++) {
            const angle = spinAngle + (Math.PI * 2 / 3) * i;
            const lineLength = this.size * 1.2;
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(this.x + Math.cos(angle) * this.size * 0.5, this.y + Math.sin(angle) * this.size * 0.5);
            ctx.lineTo(this.x + Math.cos(angle) * lineLength, this.y + Math.sin(angle) * lineLength);
            ctx.stroke();
          }
          
          // Bounces left indicator
          if (this.bouncesLeft > 0) {
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(this.bouncesLeft, this.x, this.y + 3);
          }
          
          ctx.shadowBlur = 0;
        } else if (this.type === 'taser') {
          ctx.shadowBlur = 20;
          ctx.shadowColor = '#00ffff';
          
          // Electric core
          ctx.fillStyle = '#ffffff';
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fill();
          
          // Electric aura
          ctx.strokeStyle = '#00ffff';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size + 3, 0, Math.PI * 2);
          ctx.stroke();
          
          // Lightning trails
          const trailLength = 5;
          for (let i = 0; i < 3; i++) {
            const offset = (Date.now() / 30 + i * 120) % 360;
            const trailX = this.x - Math.cos(this.angle) * i * 8;
            const trailY = this.y - Math.sin(this.angle) * i * 8;
            const perpX = trailX + Math.cos(this.angle + Math.PI / 2 + offset) * (Math.random() * 6 - 3);
            const perpY = trailY + Math.sin(this.angle + Math.PI / 2 + offset) * (Math.random() * 6 - 3);
            
            ctx.strokeStyle = `rgba(0, 255, 255, ${1 - i / 3})`;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(trailX, trailY);
            ctx.lineTo(perpX, perpY);
            ctx.stroke();
          }
          
          ctx.shadowBlur = 0;
        } else if (this.type === 'flame') {
          ctx.shadowBlur = 20;
          ctx.shadowColor = '#ff6600';
          const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
          gradient.addColorStop(0, '#ffff00');
          gradient.addColorStop(0.5, '#ff6600');
          gradient.addColorStop(1, 'rgba(255, 102, 0, 0)');
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
        } else if (this.type === 'rocket') {
          ctx.shadowBlur = 15;
          ctx.shadowColor = '#ffaa00';
          
          // Rocket body
          ctx.fillStyle = '#666666';
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.rotate(this.angle);
          ctx.fillRect(-this.size, -this.size * 0.5, this.size * 2, this.size);
          
          // Rocket tip
          ctx.fillStyle = '#ff0000';
          ctx.beginPath();
          ctx.moveTo(this.size * 2, 0);
          ctx.lineTo(this.size, -this.size * 0.5);
          ctx.lineTo(this.size, this.size * 0.5);
          ctx.closePath();
          ctx.fill();
          
          ctx.restore();
          ctx.shadowBlur = 0;
        } else {
          ctx.shadowBlur = 10;
          ctx.shadowColor = this.isPlayer ? '#ffff00' : '#ff0000';
          ctx.fillStyle = this.isPlayer ? '#ffff00' : '#ff0000';
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
        }
      }
      
      explode() {
        // Rocket explosion
        if (this.type === 'rocket') {
          for (let i = 0; i < 30; i++) {
            particles.push(new Particle(this.x, this.y, '#ff6600'));
            particles.push(new Particle(this.x, this.y, '#ffaa00'));
          }
          particles.push(new ShockwaveParticle(this.x, this.y, '#ff6600', 15));
          
          // Explosion damage
          enemies.forEach(enemy => {
            const dx = enemy.x - this.x;
            const dy = enemy.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 80) {
              enemy.takeDamage(this.damage);
            }
          });
        }
      }
    }

    class Coin {
      constructor(x, y, value) {
        this.x = x;
        this.y = y;
        this.value = value;
        this.size = 8;
        this.lifetime = 300;
        this.collected = false;
        
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 3 + 2;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed - 5;
        this.gravity = 0.3;
        this.bounce = 0.5;
      }

      update() {
        if (this.collected) return false;
        
        this.lifetime--;
        if (this.lifetime <= 0) return false;
        
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < 200) {
          const speed = 15;
          this.x += (dx / dist) * speed;
          this.y += (dy / dist) * speed;
        }
        
        if (dist < player.size + this.size + 5) {
          this.collected = true;
          totalCoins += this.value;
          updateUI();
          
          for (let i = 0; i < 8; i++) {
            particles.push(new Particle(this.x, this.y, '#ffd700'));
          }
          
          return false;
        }
        
        return true;
      }

      draw() {
        if (this.collected) return;
        
        const alpha = this.lifetime < 60 ? this.lifetime / 60 : 1;
        ctx.globalAlpha = alpha;
        
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#ffd700';
        
        ctx.fillStyle = '#ffd700';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#ffed4e';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * 0.5, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
      }
    }

    class Enemy {
      constructor(x, y, type = 'basic', floor = 1) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.angle = 0;
        this.chargeTime = 0;
        this.teleportCooldown = 0;
        this.burnTime = 0;
        this.burnDamageCounter = 0;
        
        const types = {
          basic: { size: 12, health: 20, speed: 2, shootRate: 60, damage: 5, coinValue: 1 },
          tank: { size: 18, health: 50, speed: 1, shootRate: 40, damage: 8, coinValue: 3 },
          speedy: { size: 10, health: 1, speed: 4, shootRate: 45, damage: 5, coinValue: 2 },
          sniper: { size: 11, health: 18, speed: 1.5, shootRate: 90, damage: 15, coinValue: 2 },
          charger: { size: 14, health: 25, speed: 1, shootRate: 0, damage: 10, coinValue: 2 },
          teleporter: { size: 13, health: 22, speed: 2.5, shootRate: 70, damage: 6, coinValue: 3 },
          boss: { size: 40, health: 100, speed: 1.5, shootRate: 30, damage: 8, coinValue: 20 },
          boss_tank: { size: 50, health: 150, speed: 0.8, shootRate: 20, damage: 12, coinValue: 25 },
          boss_swarm: { size: 35, health: 80, speed: 2, shootRate: 15, damage: 6, coinValue: 20 },
          boss_beam: { size: 45, health: 120, speed: 1.2, shootRate: 60, damage: 20, coinValue: 25 }
        };
        
        const props = types[type] || types.basic;
        this.size = props.size;
        this.coinValue = props.coinValue;
        
        const isBoss = type.startsWith('boss');
        this.health = props.health + (floor - 1) * (isBoss ? 30 : 5);
        this.maxHealth = this.health;
        
        this.speed = Math.min(props.speed + (floor - 1) * 0.15, isBoss ? 3 : props.speed * 1.5);
        
        this.shootCooldown = 0;
        this.shootRate = Math.max(props.shootRate - (floor - 1) * 3, props.shootRate * 0.5);
        this.bulletDamage = props.damage;
        
        this.specialCooldown = 0;
        this.beamChargeTime = 0;
        this.beamAngle = 0;
        this.stunTime = 0;
      }

      update() {
        if (this.stunTime > 0) {
          this.stunTime--;
          return;
        }

        // Burn damage over time
        if (this.burnTime > 0) {
          this.burnTime--;
          this.burnDamageCounter++;
          if (this.burnDamageCounter >= 10) {
            this.health -= 2;
            this.burnDamageCounter = 0;
            particles.push(new Particle(this.x + Math.random() * 20 - 10, this.y + Math.random() * 20 - 10, '#ff6600'));
          }
        }
        
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        this.angle = Math.atan2(dy, dx);
        
        if (this.type === 'boss_tank') {
          if (dist > 100) {
            this.x += (dx / dist) * this.speed;
            this.y += (dy / dist) * this.speed;
          }
        } else if (this.type === 'boss_swarm') {
          const circleAngle = this.angle + Math.PI / 3;
          this.x += (dx / dist) * this.speed * 0.5 + Math.cos(circleAngle) * this.speed;
          this.y += (dy / dist) * this.speed * 0.5 + Math.sin(circleAngle) * this.speed;
        } else if (this.type === 'boss_beam') {
          if (this.beamChargeTime > 0) {
            this.beamChargeTime--;
            this.beamAngle = this.angle;
          } else if (dist > 150 && dist < 400) {
            const moveAngle = this.angle + Math.PI / 2;
            this.x += Math.cos(moveAngle) * this.speed;
            this.y += Math.sin(moveAngle) * this.speed;
          } else if (dist > 400) {
            this.x += (dx / dist) * this.speed;
            this.y += (dy / dist) * this.speed;
          }
        } else if (this.type === 'charger') {
          if (this.chargeTime > 0) {
            this.chargeTime--;
            this.x += Math.cos(this.angle) * 8;
            this.y += Math.sin(this.angle) * 8;
          } else if (dist > 100) {
            this.x += (dx / dist) * this.speed;
            this.y += (dy / dist) * this.speed;
            if (Math.random() < 0.01) {
              this.chargeTime = 30;
            }
          }
        } else if (this.type === 'teleporter') {
          if (this.teleportCooldown > 0) {
            this.teleportCooldown--;
          } else if (Math.random() < 0.005) {
            this.x = Math.random() * (ROOM_WIDTH - 100) + 50;
            this.y = Math.random() * (ROOM_HEIGHT - 100) + 50;
            this.teleportCooldown = 120;
            for (let i = 0; i < 15; i++) {
              particles.push(new Particle(this.x, this.y, '#00ffff'));
            }
          } else if (dist > 50) {
            this.x += (dx / dist) * this.speed;
            this.y += (dy / dist) * this.speed;
          }
        } else if (this.type === 'sniper') {
          if (dist < 250 && dist > 50) {
            this.x -= (dx / dist) * this.speed;
            this.y -= (dy / dist) * this.speed;
          } else if (dist > 300) {
            this.x += (dx / dist) * this.speed;
            this.y += (dy / dist) * this.speed;
          }
        } else if (this.type === 'speedy') {
          const circleAngle = this.angle + Math.PI / 2;
          this.x += (dx / dist) * this.speed * 0.3 + Math.cos(circleAngle) * this.speed;
          this.y += (dy / dist) * this.speed * 0.3 + Math.sin(circleAngle) * this.speed;
        } else {
          if (dist > 50) {
            this.x += (dx / dist) * this.speed;
            this.y += (dy / dist) * this.speed;
          }
        }

        this.x = Math.max(this.size + 10, Math.min(ROOM_WIDTH - this.size - 10, this.x));
        this.y = Math.max(this.size + 10, Math.min(ROOM_HEIGHT - this.size - 10, this.y));

        if (this.type !== 'charger') {
          if (this.shootCooldown > 0) {
            this.shootCooldown--;
          } else {
            const bulletSpeed = this.type === 'sniper' ? 15 : this.type === 'speedy' ? 10 : 8;
            const bulletSize = this.type === 'sniper' ? 3 : this.type === 'tank' ? 6 : 4;
            
            if (this.type === 'boss_tank') {
              for (let i = 0; i < 8; i++) {
                const spreadAngle = (Math.PI * 2 / 8) * i;
                bullets.push(new Bullet(this.x, this.y, spreadAngle, false, { 
                  speed: 7, size: 6, damage: this.bulletDamage 
                }));
              }
            } else if (this.type === 'boss_swarm') {
              for (let i = -1; i <= 1; i += 2) {
                const spreadAngle = this.angle + i * 0.2;
                bullets.push(new Bullet(this.x, this.y, spreadAngle, false, { 
                  speed: 10, size: 4, damage: this.bulletDamage 
                }));
              }
            } else if (this.type === 'boss_beam') {
              if (this.specialCooldown === 0 && Math.random() < 0.3) {
                this.beamChargeTime = 60;
                this.beamAngle = this.angle;
                this.specialCooldown = 180;
              } else {
                bullets.push(new Bullet(this.x, this.y, this.angle, false, { 
                  speed: 12, size: 5, damage: this.bulletDamage 
                }));
              }
            } else if (this.type === 'tank') {
              for (let i = -1; i <= 1; i++) {
                const spreadAngle = this.angle + i * 0.3;
                bullets.push(new Bullet(this.x, this.y, spreadAngle, false, { 
                  speed: bulletSpeed, size: bulletSize, damage: this.bulletDamage 
                }));
              }
            } else {
              bullets.push(new Bullet(this.x, this.y, this.angle, false, { 
                speed: bulletSpeed, size: bulletSize, damage: this.bulletDamage 
              }));
            }
            
            this.shootCooldown = this.shootRate;
          }
        }
        
        if (this.specialCooldown > 0) {
          this.specialCooldown--;
        }
        
        if (this.type === 'boss_beam' && this.beamChargeTime === 1) {
          for (let i = 0; i < 5; i++) {
            const spreadAngle = this.beamAngle + (i - 2) * 0.05;
            bullets.push(new Bullet(this.x, this.y, spreadAngle, false, { 
              speed: 18, size: 6, damage: this.bulletDamage 
            }));
          }
        }
      }

      takeDamage(amount) {
        this.health -= amount;
        return this.health <= 0;
      }

      draw() {
        if (this.health < this.maxHealth) {
          const barWidth = this.size * 2;
          const barHeight = 4;
          ctx.fillStyle = '#300';
          ctx.fillRect(this.x - barWidth / 2, this.y - this.size - 10, barWidth, barHeight);
          ctx.fillStyle = '#ff0000';
          ctx.fillRect(this.x - barWidth / 2, this.y - this.size - 10, (this.health / this.maxHealth) * barWidth, barHeight);
        }

        // Burn effect
        if (this.burnTime > 0) {
          ctx.shadowBlur = 20;
          ctx.shadowColor = '#ff6600';
          
          // Draw flames around enemy
          for (let i = 0; i < 5; i++) {
            const angle = (Math.PI * 2 / 5) * i + (Date.now() / 100);
            const flameX = this.x + Math.cos(angle) * (this.size + 5);
            const flameY = this.y + Math.sin(angle) * (this.size + 5) - Math.abs(Math.sin(Date.now() / 100 + i)) * 8;
            
            const gradient = ctx.createRadialGradient(flameX, flameY, 0, flameX, flameY, 8);
            gradient.addColorStop(0, '#ffff00');
            gradient.addColorStop(0.5, '#ff6600');
            gradient.addColorStop(1, 'rgba(255, 102, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(flameX, flameY, 8, 0, Math.PI * 2);
            ctx.fill();
          }
          
          // Fire icon above enemy
          ctx.fillStyle = '#ff6600';
          ctx.font = 'bold 20px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('ðŸ”¥', this.x, this.y - this.size - 25);
          
          ctx.shadowBlur = 0;
        }

        // Electric stun effect
        if (this.stunTime > 0) {
          ctx.shadowBlur = 15;
          ctx.shadowColor = '#00ffff';
          ctx.strokeStyle = '#00ffff';
          ctx.lineWidth = 2;
          
          // Draw lightning arcs around enemy
          for (let i = 0; i < 5; i++) {
            const angle = (Math.PI * 2 / 5) * i + (Date.now() / 50);
            const startX = this.x + Math.cos(angle) * this.size;
            const startY = this.y + Math.sin(angle) * this.size;
            const endX = this.x + Math.cos(angle + 0.5) * (this.size + 10);
            const endY = this.y + Math.sin(angle + 0.5) * (this.size + 10);
            
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
          }
          
          // Stun indicator above enemy
          ctx.fillStyle = '#ffff00';
          ctx.font = 'bold 20px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('âš¡', this.x, this.y - this.size - 25);
          
          ctx.shadowBlur = 0;
        }

        const colors = {
          basic: { main: '#ff3333', glow: '#ff0000' },
          tank: { main: '#886600', glow: '#ffaa00' },
          speedy: { main: '#00ff88', glow: '#00ff00' },
          sniper: { main: '#8844ff', glow: '#6600ff' },
          charger: { main: '#ff8800', glow: '#ff6600' },
          teleporter: { main: '#00ffff', glow: '#00aaff' },
          boss: { main: '#ff00ff', glow: '#ff00ff' },
          boss_tank: { main: '#ffaa00', glow: '#ff8800' },
          boss_swarm: { main: '#00ff00', glow: '#00ff88' },
          boss_beam: { main: '#00ffff', glow: '#0088ff' }
        };
        
        const color = colors[this.type] || colors.basic;
        ctx.shadowBlur = 15;
        ctx.shadowColor = color.glow;
        ctx.fillStyle = color.main;
        
        if (this.type === 'boss') {
          ctx.beginPath();
          for (let i = 0; i < 8; i++) {
            const angle = (Math.PI * 2 / 8) * i;
            const radius = i % 2 === 0 ? this.size : this.size * 0.6;
            const x = this.x + Math.cos(angle) * radius;
            const y = this.y + Math.sin(angle) * radius;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.closePath();
          ctx.fill();
        } else if (this.type === 'boss_tank') {
          ctx.beginPath();
          for (let i = 0; i < 5; i++) {
            const angle = (Math.PI * 2 / 5) * i - Math.PI / 2;
            const x = this.x + Math.cos(angle) * this.size;
            const y = this.y + Math.sin(angle) * this.size;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.closePath();
          ctx.fill();
          ctx.fillStyle = '#664400';
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size * 0.5, 0, Math.PI * 2);
          ctx.fill();
        } else if (this.type === 'boss_swarm') {
          const spinAngle = Date.now() / 100;
          ctx.beginPath();
          for (let i = 0; i < 6; i++) {
            const angle = (Math.PI * 2 / 6) * i + spinAngle;
            const radius = i % 2 === 0 ? this.size : this.size * 0.7;
            const x = this.x + Math.cos(angle) * radius;
            const y = this.y + Math.sin(angle) * radius;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.closePath();
          ctx.fill();
        } else if (this.type === 'boss_beam') {
          ctx.beginPath();
          for (let i = 0; i < 6; i++) {
            const angle = (Math.PI * 2 / 6) * i;
            const x = this.x + Math.cos(angle) * this.size;
            const y = this.y + Math.sin(angle) * this.size;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.closePath();
          ctx.fill();
          if (this.beamChargeTime > 0) {
            const chargeProgress = 1 - (this.beamChargeTime / 60);
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 4;
            ctx.globalAlpha = chargeProgress;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size + 10, 0, Math.PI * 2 * chargeProgress);
            ctx.stroke();
            ctx.globalAlpha = 1;
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            const beamLength = 600;
            ctx.lineTo(
              this.x + Math.cos(this.beamAngle) * beamLength,
              this.y + Math.sin(this.beamAngle) * beamLength
            );
            ctx.stroke();
          }
        } else if (this.type === 'tank') {
          ctx.fillRect(this.x - this.size, this.y - this.size, this.size * 2, this.size * 2);
        } else if (this.type === 'speedy') {
          ctx.beginPath();
          for (let i = 0; i < 3; i++) {
            const angle = (Math.PI * 2 / 3) * i + this.angle;
            const x = this.x + Math.cos(angle) * this.size;
            const y = this.y + Math.sin(angle) * this.size;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.closePath();
          ctx.fill();
        } else if (this.type === 'sniper') {
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = color.main;
          ctx.lineWidth = 2;
          const crosshairDist = this.size + 5;
          ctx.beginPath();
          ctx.moveTo(this.x - crosshairDist, this.y);
          ctx.lineTo(this.x + crosshairDist, this.y);
          ctx.moveTo(this.x, this.y - crosshairDist);
          ctx.lineTo(this.x, this.y + crosshairDist);
          ctx.stroke();
        } else if (this.type === 'charger') {
          ctx.beginPath();
          const points = 5;
          for (let i = 0; i < points * 2; i++) {
            const angle = (Math.PI * 2 / (points * 2)) * i;
            const radius = i % 2 === 0 ? this.size : this.size * 0.5;
            const x = this.x + Math.cos(angle) * radius;
            const y = this.y + Math.sin(angle) * radius;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.closePath();
          ctx.fill();
        } else if (this.type === 'teleporter') {
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fill();
          if (this.teleportCooldown > 100) {
            ctx.strokeStyle = color.main;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size + 5, 0, Math.PI * 2);
            ctx.stroke();
          }
        } else {
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.shadowBlur = 0;
      }
    }

    class WeaponPickup {
      constructor(x, y, weaponType) {
        this.x = x;
        this.y = y;
        this.weaponType = weaponType;
        this.size = 20;
        this.collected = false;
      }

      checkCollision(player) {
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < player.size + this.size && !this.collected) {
          player.setWeapon(this.weaponType);
          this.collected = true;
          return true;
        }
        return false;
      }

      draw() {
        if (this.collected) return;

        const offset = Math.sin(Date.now() / 300) * 5;
        
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#ffaa00';
        
        ctx.fillStyle = '#ffaa00';
        ctx.beginPath();
        ctx.arc(this.x, this.y + offset, this.size, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#000';
        ctx.font = 'bold 20px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        let symbol = 'â—†';
        if (this.weaponType === WEAPONS.AUTOBLASTER) symbol = 'âš¡';
        else if (this.weaponType === WEAPONS.CANNON) symbol = 'â—';
        else if (this.weaponType === WEAPONS.BAZOOKA) symbol = 'â˜…';
        else if (this.weaponType === WEAPONS.SNIPER) symbol = 'â–²';
        else if (this.weaponType === WEAPONS.MINIGUN) symbol = 'âš™';
        else if (this.weaponType === WEAPONS.SHOTGUN) symbol = 'â‰¡';
        else if (this.weaponType === WEAPONS.FLAMETHROWER) symbol = 'ðŸ”¥';
        else if (this.weaponType === WEAPONS.ROCKET) symbol = 'ðŸš€';
        else if (this.weaponType === WEAPONS.TASER) symbol = 'âš¡';
        else if (this.weaponType === WEAPONS.BOUNCER) symbol = 'â†»';
        else if (this.weaponType === WEAPONS.HOMING) symbol = 'ðŸŽ¯';
        
        ctx.fillText(symbol, this.x, this.y + offset);
        
        ctx.shadowBlur = 0;
        
        ctx.fillStyle = '#ffaa00';
        ctx.font = 'bold 12px Courier New';
        ctx.fillText(this.weaponType.name, this.x, this.y + offset + 35);
      }
    }

    class Particle {
      constructor(x, y, color) {
        this.x = x;
        this.y = y;
        
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 12 + 4;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.size = Math.random() * 8 + 3;
        this.lifetime = 40;
        
        this.color = color;
        this.gravity = 0.3;
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += this.gravity;
        this.vx *= 0.98;
        this.vy *= 0.98;
        this.lifetime--;
        this.size *= 0.96;
        return this.lifetime > 0;
      }

      draw() {
        ctx.globalAlpha = this.lifetime / 40;
        ctx.shadowBlur = 8;
        ctx.shadowColor = this.color;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
      }
    }

    class ShockwaveParticle {
      constructor(x, y, color, size) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.radius = size;
        this.maxRadius = size * 3;
        this.lifetime = 20;
        this.maxLifetime = 20;
      }

      update() {
        this.radius += (this.maxRadius - this.radius) * 0.3;
        this.lifetime--;
        return this.lifetime > 0;
      }

      draw() {
        ctx.globalAlpha = this.lifetime / this.maxLifetime;
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 3;
        ctx.shadowBlur = 15;
        ctx.shadowColor = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
      }
    }

    class Room {
      constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.cleared = false;
        this.visited = false;
        this.doors = { north: false, south: false, east: false, west: false };
      }
    }

    function generateDungeon() {
      const rooms = [];
      const startRoom = new Room(0, 0, ROOM_TYPES.START);
      startRoom.visited = true;
      rooms.push(startRoom);

      const roomCount = 5 + Math.floor(currentFloor * 1.5);
      let attempts = 0;
      
      while (rooms.length < roomCount && attempts < 100) {
        attempts++;
        const baseRoom = rooms[Math.floor(Math.random() * rooms.length)];
        const directions = [
          { dx: 1, dy: 0, door: 'east', opposite: 'west' },
          { dx: -1, dy: 0, door: 'west', opposite: 'east' },
          { dx: 0, dy: 1, door: 'south', opposite: 'north' },
          { dx: 0, dy: -1, door: 'north', opposite: 'south' }
        ];
        
        const dir = directions[Math.floor(Math.random() * directions.length)];
        const newX = baseRoom.x + dir.dx;
        const newY = baseRoom.y + dir.dy;
        
        if (!rooms.find(r => r.x === newX && r.y === newY)) {
          const newRoom = new Room(newX, newY, ROOM_TYPES.NORMAL);
          baseRoom.doors[dir.door] = true;
          newRoom.doors[dir.opposite] = true;
          rooms.push(newRoom);
        }
      }

      let maxDist = 0;
      let bossRoom = rooms[rooms.length - 1];
      rooms.forEach(room => {
        const dist = Math.abs(room.x) + Math.abs(room.y);
        if (dist > maxDist) {
          maxDist = dist;
          bossRoom = room;
        }
      });
      bossRoom.type = ROOM_TYPES.BOSS;

      const treasureCount = Math.random() < 0.6 ? 1 : 0;
      const normalRooms = rooms.filter(r => r.type === ROOM_TYPES.NORMAL);
      for (let i = 0; i < treasureCount && normalRooms.length > 0; i++) {
        const idx = Math.floor(Math.random() * normalRooms.length);
        normalRooms[idx].type = ROOM_TYPES.TREASURE;
        normalRooms.splice(idx, 1);
      }

      return rooms;
    }

    function initGame() {
      player = new Player(ROOM_WIDTH / 2, ROOM_HEIGHT / 2);
      bullets = [];
      enemies = [];
      particles = [];
      coins = [];
      weaponPickup = null;
      rooms = generateDungeon();
      currentRoom = rooms[0];
      updateUI();
    }

    function startRoom(resetPlayer = true) {
      enemies = [];
      bullets = [];
      weaponPickup = null;
      
      // Halo passive: every 4th room with enemies gets instantly cleared
      if (hasHalo && currentRoom.type !== ROOM_TYPES.BOSS && currentRoom.type !== ROOM_TYPES.START && currentRoom.type !== ROOM_TYPES.TREASURE && !currentRoom.cleared) {
        haloRoomCounter++;
        if (haloRoomCounter >= 4) {
          haloRoomCounter = 0;
          currentRoom.cleared = true;
          
          // Divine clear effect
          particles.push(new ShockwaveParticle(ROOM_WIDTH / 2, ROOM_HEIGHT / 2, '#ffff00', 50));
          for (let i = 0; i < 100; i++) {
            particles.push(new Particle(
              ROOM_WIDTH / 2 + (Math.random() - 0.5) * 200,
              ROOM_HEIGHT / 2 + (Math.random() - 0.5) * 200,
              '#ffff00'
            ));
          }
          
          // Show divine message
          const divineMsg = document.createElement('div');
          divineMsg.textContent = 'âœ¨ DIVINE INTERVENTION âœ¨';
          divineMsg.style.position = 'fixed';
          divineMsg.style.top = '40%';
          divineMsg.style.left = '50%';
          divineMsg.style.transform = 'translate(-50%, -50%)';
          divineMsg.style.fontSize = '36px';
          divineMsg.style.color = '#ffff00';
          divineMsg.style.fontWeight = 'bold';
          divineMsg.style.textShadow = '0 0 30px #ffff00';
          divineMsg.style.zIndex = '1000';
          divineMsg.style.pointerEvents = 'none';
          divineMsg.style.fontFamily = "'Courier New', monospace";
          document.body.appendChild(divineMsg);
          
          setTimeout(() => {
            divineMsg.remove();
          }, 2000);
          
          return; // Skip spawning enemies
        }
      }
      
      if (currentRoom.type === ROOM_TYPES.BOSS && !currentRoom.cleared) {
        const bossTypes = ['boss', 'boss_tank', 'boss_swarm', 'boss_beam'];
        const bossType = bossTypes[(currentFloor - 1) % bossTypes.length];
        enemies.push(new Enemy(ROOM_WIDTH / 2, 200, bossType, currentFloor));
      } else if (currentRoom.type === ROOM_TYPES.TREASURE && !currentRoom.cleared) {
        const weaponTypes = [WEAPONS.AUTOBLASTER, WEAPONS.CANNON, WEAPONS.BAZOOKA, WEAPONS.SNIPER, WEAPONS.MINIGUN, WEAPONS.SHOTGUN, WEAPONS.FLAMETHROWER, WEAPONS.ROCKET, WEAPONS.TASER, WEAPONS.BOUNCER, WEAPONS.HOMING];
        const randomWeapon = weaponTypes[Math.floor(Math.random() * weaponTypes.length)];
        weaponPickup = new WeaponPickup(ROOM_WIDTH / 2, ROOM_HEIGHT / 2, randomWeapon);
      } else if (!currentRoom.cleared && currentRoom.type !== ROOM_TYPES.START) {
        const enemyCount = 3 + Math.floor(currentFloor * 0.8);
        const enemyTypes = ['basic', 'tank', 'speedy', 'sniper', 'charger', 'teleporter'];
        
        for (let i = 0; i < enemyCount; i++) {
          const x = Math.random() * (ROOM_WIDTH - 100) + 50;
          const y = Math.random() * 300 + 50;
          
          let type = 'basic';
          const rand = Math.random();
          
          if (currentFloor >= 3) {
            if (rand < 0.15) type = 'tank';
            else if (rand < 0.3) type = 'speedy';
            else if (rand < 0.45) type = 'sniper';
            else if (rand < 0.6) type = 'charger';
            else if (rand < 0.75) type = 'teleporter';
          } else if (currentFloor >= 2) {
            if (rand < 0.2) type = 'tank';
            else if (rand < 0.4) type = 'speedy';
            else if (rand < 0.6) type = 'charger';
          } else {
            if (rand < 0.3) type = 'speedy';
          }
          
          enemies.push(new Enemy(x, y, type, currentFloor));
        }
      }
      
      if (resetPlayer) {
        player.x = ROOM_WIDTH / 2;
        player.y = ROOM_HEIGHT / 2;
      }
    }

    function checkRoomCleared() {
      if (enemies.length === 0 && !currentRoom.cleared) {
        currentRoom.cleared = true;
        
        if (currentRoom.type === ROOM_TYPES.BOSS) {
          gameState = 'victory';
          showVictory();
        }
      }
    }

    function changeRoom(direction) {
      if (!currentRoom.doors[direction] || enemies.length > 0) return false;

      const offsets = {
        north: { dx: 0, dy: -1 },
        south: { dx: 0, dy: 1 },
        east: { dx: 1, dy: 0 },
        west: { dx: -1, dy: 0 }
      };

      const offset = offsets[direction];
      const newRoom = rooms.find(r => 
        r.x === currentRoom.x + offset.dx && 
        r.y === currentRoom.y + offset.dy
      );

      if (newRoom) {
        currentRoom = newRoom;
        currentRoom.visited = true;
        
        if (direction === 'north') player.y = ROOM_HEIGHT - 60;
        if (direction === 'south') player.y = 60;
        if (direction === 'east') player.x = 60;
        if (direction === 'west') player.x = ROOM_WIDTH - 60;
        
        // Grant 1 second (60 frames) of invincibility
        player.invincibilityTime = 60;
        
        startRoom(false);
        return true;
      }
      return false;
    }

    function update() {
      if (gameState !== 'playing') return;

      player.update();
      
      // Update dog if player has one
      if (hasDog && dog) {
        dog.update();
      }

      // Continuous fire when holding mouse button
      if (mouseDown) {
        player.shoot(mouse.x, mouse.y);
      }

      if (weaponPickup && !weaponPickup.collected) {
        if (weaponPickup.checkCollision(player)) {
          checkRoomCleared();
        }
      }

      const canLeave = enemies.length === 0;
      const doorSize = 60;
      
      // North door
      if (currentRoom.doors.north && 
          player.y < 40 && 
          Math.abs(player.x - ROOM_WIDTH / 2) < doorSize / 2 &&
          canLeave) {
        changeRoom('north');
      }
      // South door
      if (currentRoom.doors.south && 
          player.y > ROOM_HEIGHT - 40 && 
          Math.abs(player.x - ROOM_WIDTH / 2) < doorSize / 2 &&
          canLeave) {
        changeRoom('south');
      }
      // West door
      if (currentRoom.doors.west && 
          player.x < 40 && 
          Math.abs(player.y - ROOM_HEIGHT / 2) < doorSize / 2 &&
          canLeave) {
        changeRoom('west');
      }
      // East door
      if (currentRoom.doors.east && 
          player.x > ROOM_WIDTH - 40 && 
          Math.abs(player.y - ROOM_HEIGHT / 2) < doorSize / 2 &&
          canLeave) {
        changeRoom('east');
      }

      bullets = bullets.filter(b => b.update());
      coins = coins.filter(c => c.update());
      enemies.forEach(e => e.update());

      // Check punch melee damage
      if (player.punchTime > 0 && player.punchTime === 12) {
        const punchDistance = 40;
        const punchX = player.x + Math.cos(player.punchAngle) * punchDistance;
        const punchY = player.y + Math.sin(player.punchAngle) * punchDistance;
        const punchRadius = 25;
        const brassKnuckleBonus = hasBrassKnuckles ? (1 + brassKnuckleStacks * 0.1) : 1;
        const punchDamage = Math.floor(35 * damageMultiplier * brassKnuckleBonus);
        
        enemies.forEach((enemy, i) => {
          const dx = enemy.x - punchX;
          const dy = enemy.y - punchY;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < enemy.size + punchRadius) {
            // Apply knockback
            const knockbackPower = 50;
            const knockbackAngle = Math.atan2(dy, dx);
            enemy.x += Math.cos(knockbackAngle) * knockbackPower;
            enemy.y += Math.sin(knockbackAngle) * knockbackPower;
            
            // Keep enemy in bounds
            enemy.x = Math.max(enemy.size + 10, Math.min(ROOM_WIDTH - enemy.size - 10, enemy.x));
            enemy.y = Math.max(enemy.size + 10, Math.min(ROOM_HEIGHT - enemy.size - 10, enemy.y));
            
            if (enemy.takeDamage(punchDamage)) {
              const particleColors = {
                basic: '#ff3333',
                tank: '#ffaa00',
                speedy: '#00ff88',
                sniper: '#8844ff',
                charger: '#ff8800',
                teleporter: '#00ffff',
                boss: '#ff00ff',
                boss_tank: '#ffaa00',
                boss_swarm: '#00ff00',
                boss_beam: '#00ffff'
              };
              const particleColor = particleColors[enemy.type] || '#ff3333';
              
              const particleCount = enemy.type.startsWith('boss') ? 50 : 25;
              for (let j = 0; j < particleCount; j++) {
                particles.push(new Particle(enemy.x, enemy.y, particleColor));
              }
              
              particles.push(new ShockwaveParticle(enemy.x, enemy.y, particleColor, enemy.size));
              
              let coinCount;
              if (enemy.type.startsWith('boss')) {
                coinCount = 5;
              } else {
                coinCount = Math.ceil(enemy.coinValue * (0.5 + Math.random() * 0.5));
              }
              const coinMultiplier = hasPennyPincher ? 2 : 1;
              for (let j = 0; j < coinCount * coinMultiplier; j++) {
                coins.push(new Coin(enemy.x, enemy.y, 1));
              }
              
              // Sugar Rush: increase stacks on hit
              if (hasSugarRush) {
                sugarRushStacks = Math.min(sugarRushStacks + 1, 10);
              }
              
              // Brass Knuckles: increase damage stacks on punch kill
              if (hasBrassKnuckles) {
                brassKnuckleStacks++;
                // Visual feedback for brass knuckles stack gain
                for (let j = 0; j < 10; j++) {
                  particles.push(new Particle(player.x, player.y, '#ffaa00'));
                }
              }
              
              enemies.splice(i, 1);
              totalKills++;
              updateUI();
            } else {
              // Visual feedback even if enemy survives
              for (let j = 0; j < 8; j++) {
                particles.push(new Particle(enemy.x, enemy.y, '#00ffff'));
              }
            }
          }
        });
      }

      bullets.forEach(bullet => {
        if (bullet.isPlayer) {
          let bulletHit = false;
          enemies.forEach((enemy, i) => {
            // Skip if this is a bouncer that just hit this enemy
            if (bullet.type === 'bouncer' && bullet.lastHitEnemy === enemy) {
              return;
            }
            
            const dx = bullet.x - enemy.x;
            const dy = bullet.y - enemy.y;
            if (Math.sqrt(dx * dx + dy * dy) < enemy.size + bullet.size) {
              // Bouncer logic - bounce to another enemy
              if (bullet.type === 'bouncer' && bullet.bouncesLeft > 0) {
                bullet.lastHitEnemy = enemy;
                bullet.bouncesLeft--;
                
                // Apply damage
                if (enemy.takeDamage(bullet.damage)) {
                  const particleColors = {
                    basic: '#ff3333',
                    tank: '#ffaa00',
                    speedy: '#00ff88',
                    sniper: '#8844ff',
                    charger: '#ff8800',
                    teleporter: '#00ffff',
                    boss: '#ff00ff',
                    boss_tank: '#ffaa00',
                    boss_swarm: '#00ff00',
                    boss_beam: '#00ffff'
                  };
                  const particleColor = particleColors[enemy.type] || '#ff3333';
                  
                  const particleCount = enemy.type.startsWith('boss') ? 50 : 25;
                  for (let j = 0; j < particleCount; j++) {
                    particles.push(new Particle(enemy.x, enemy.y, particleColor));
                  }
                  
                  particles.push(new ShockwaveParticle(enemy.x, enemy.y, particleColor, enemy.size));
                  
                  // Vampire lifesteal
                  if (hasVampire) {
                    const lifestealAmount = enemy.type.startsWith('boss') ? 15 : 5;
                    player.health = Math.min(player.health + lifestealAmount, player.maxHealth);
                    
                    // Blood particles flying to player
                    for (let j = 0; j < 10; j++) {
                      const bloodParticle = new Particle(enemy.x, enemy.y, '#ff0066');
                      const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                      bloodParticle.vx = Math.cos(angle) * 10;
                      bloodParticle.vy = Math.sin(angle) * 10;
                      particles.push(bloodParticle);
                    }
                    updateUI();
                  }
                  
                  let coinCount;
                  if (enemy.type.startsWith('boss')) {
                    coinCount = 5;
                  } else {
                    coinCount = Math.ceil(enemy.coinValue * (0.5 + Math.random() * 0.5));
                  }
                  const coinMultiplier = hasPennyPincher ? 2 : 1;
                  for (let j = 0; j < coinCount * coinMultiplier; j++) {
                    coins.push(new Coin(enemy.x, enemy.y, 1));
                  }
                  
                  // Sugar Rush: increase stacks on hit
                  if (hasSugarRush) {
                    sugarRushStacks = Math.min(sugarRushStacks + 1, 10);
                  }
                  
                  enemies.splice(i, 1);
                  totalKills++;
                  updateUI();
                } else {
                  // Enemy survived, visual feedback
                  for (let j = 0; j < 8; j++) {
                    particles.push(new Particle(enemy.x, enemy.y, '#00ffaa'));
                  }
                }
                
                // Find another enemy to bounce to
                let closestEnemy = null;
                let closestDist = Infinity;
                
                enemies.forEach(otherEnemy => {
                  if (otherEnemy !== enemy) {
                    const dx2 = otherEnemy.x - bullet.x;
                    const dy2 = otherEnemy.y - bullet.y;
                    const dist = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                    
                    if (dist < closestDist && dist < 300) {
                      closestDist = dist;
                      closestEnemy = otherEnemy;
                    }
                  }
                });
                
                if (closestEnemy) {
                  // Bounce towards the closest enemy
                  const bounceAngle = Math.atan2(closestEnemy.y - bullet.y, closestEnemy.x - bullet.x);
                  const speed = Math.sqrt(bullet.vx * bullet.vx + bullet.vy * bullet.vy);
                  bullet.vx = Math.cos(bounceAngle) * speed * 1.1;
                  bullet.vy = Math.sin(bounceAngle) * speed * 1.1;
                  bullet.angle = bounceAngle;
                  
                  // Bounce effect
                  particles.push(new ShockwaveParticle(bullet.x, bullet.y, '#00ffaa', 10));
                  for (let j = 0; j < 12; j++) {
                    particles.push(new Particle(bullet.x, bullet.y, '#00ffaa'));
                  }
                } else {
                  // No more enemies to bounce to
                  bullet.lifetime = 0;
                }
                
                return;
              }
              
              bulletHit = true;
              
              // Apply stun effect from taser
              if (bullet.type === 'taser') {
                enemy.stunTime = bullet.weapon.stunDuration || 120;
                
                // Electric particle explosion
                for (let j = 0; j < 20; j++) {
                  particles.push(new Particle(enemy.x, enemy.y, '#00ffff'));
                }
                particles.push(new ShockwaveParticle(enemy.x, enemy.y, '#00ffff', enemy.size));
              }

              // Apply burn effect from Hotshot
              if (hasHotshot) {
                enemy.burnTime = 180; // 3 seconds of burn
                for (let j = 0; j < 10; j++) {
                  particles.push(new Particle(enemy.x, enemy.y, '#ff6600'));
                }
              }
              
              if (enemy.takeDamage(bullet.damage)) {
                const particleColors = {
                  basic: '#ff3333',
                  tank: '#ffaa00',
                  speedy: '#00ff88',
                  sniper: '#8844ff',
                  charger: '#ff8800',
                  teleporter: '#00ffff',
                  boss: '#ff00ff',
                  boss_tank: '#ffaa00',
                  boss_swarm: '#00ff00',
                  boss_beam: '#00ffff'
                };
                const particleColor = particleColors[enemy.type] || '#ff3333';
                
                const particleCount = enemy.type.startsWith('boss') ? 50 : 25;
                for (let j = 0; j < particleCount; j++) {
                  particles.push(new Particle(enemy.x, enemy.y, particleColor));
                }
                
                particles.push(new ShockwaveParticle(enemy.x, enemy.y, particleColor, enemy.size));
                
                // Vampire lifesteal
                if (hasVampire) {
                  const lifestealAmount = enemy.type.startsWith('boss') ? 15 : 5;
                  player.health = Math.min(player.health + lifestealAmount, player.maxHealth);
                  
                  // Blood particles flying to player
                  for (let j = 0; j < 10; j++) {
                    const bloodParticle = new Particle(enemy.x, enemy.y, '#ff0066');
                    const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                    bloodParticle.vx = Math.cos(angle) * 10;
                    bloodParticle.vy = Math.sin(angle) * 10;
                    particles.push(bloodParticle);
                  }
                  updateUI();
                }
                
                let coinCount;
                if (enemy.type.startsWith('boss')) {
                  coinCount = 5;
                } else {
                  coinCount = Math.ceil(enemy.coinValue * (0.5 + Math.random() * 0.5));
                }
                const coinMultiplier = hasPennyPincher ? 2 : 1;
                for (let j = 0; j < coinCount * coinMultiplier; j++) {
                  coins.push(new Coin(enemy.x, enemy.y, 1));
                }
                
                // Sugar Rush: increase stacks on hit
                if (hasSugarRush) {
                  sugarRushStacks = Math.min(sugarRushStacks + 1, 10);
                }
                
                enemies.splice(i, 1);
                totalKills++;
                updateUI();
              }
            }
          });
          
        if (bulletHit) {
          if (bullet.type === 'rocket' || hasKaboom) {
            bullet.explode();
          }
          bullet.lifetime = 0;
        }
        } else {
          let bulletDeflected = false;
            
            if (player.punchTime > 0) {
              const dx = bullet.x - player.x;
              const dy = bullet.y - player.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              const bulletAngle = Math.atan2(dy, dx);
              let angleDiff = Math.abs(bulletAngle - player.punchAngle);
              
              // Normalize angle difference to 0-PI range
              if (angleDiff > Math.PI) {
                angleDiff = Math.PI * 2 - angleDiff;
              }
              
              if (dist < 50 && angleDiff < 0.8) {
                bullet.isPlayer = true;
                const reflectAngle = player.punchAngle;
                bullet.vx = Math.cos(reflectAngle) * 16;
                bullet.vy = Math.sin(reflectAngle) * 16;
                bullet.damage = Math.floor(bullet.damage * 2);
                bulletDeflected = true;
                
                for (let i = 0; i < 15; i++) {
                  particles.push(new Particle(bullet.x, bullet.y, '#00ffff'));
                }
                particles.push(new ShockwaveParticle(bullet.x, bullet.y, '#00ffff', 8));
              }
            }
            
          if (!bulletDeflected) {
            const dx = bullet.x - player.x;
            const dy = bullet.y - player.y;
            if (Math.sqrt(dx * dx + dy * dy) < player.size + bullet.size && player.dashTime === 0 && player.invincibilityTime === 0) {
              player.takeDamage(bullet.damage);
              updateUI();
              bullet.lifetime = 0;
            }
          }
        }
      });

      particles = particles.filter(p => p.update());
      checkRoomCleared();
    }

    function drawRoom() {
      if (currentRoom.type === ROOM_TYPES.TREASURE) {
        ctx.fillStyle = '#2a2a10';
      } else if (currentRoom.type === ROOM_TYPES.BOSS) {
        ctx.fillStyle = '#2a1a2a';
      } else {
        ctx.fillStyle = '#2a2a2a';
      }
      ctx.fillRect(0, 0, ROOM_WIDTH, ROOM_HEIGHT);

      if (currentRoom.type === ROOM_TYPES.TREASURE) {
        ctx.strokeStyle = '#ffaa00';
      } else {
        ctx.strokeStyle = '#ff0000';
      }
      ctx.lineWidth = 3;
      ctx.strokeRect(2, 2, ROOM_WIDTH - 4, ROOM_HEIGHT - 4);

      function doorLeadsToBoss(direction) {
        const offsets = {
          north: { dx: 0, dy: -1 },
          south: { dx: 0, dy: 1 },
          east: { dx: 1, dy: 0 },
          west: { dx: -1, dy: 0 }
        };
        const offset = offsets[direction];
        const nextRoom = rooms.find(r => 
          r.x === currentRoom.x + offset.dx && 
          r.y === currentRoom.y + offset.dy
        );
        return nextRoom && nextRoom.type === ROOM_TYPES.BOSS;
      }

      function doorLeadsToTreasure(direction) {
        const offsets = {
          north: { dx: 0, dy: -1 },
          south: { dx: 0, dy: 1 },
          east: { dx: 1, dy: 0 },
          west: { dx: -1, dy: 0 }
        };
        const offset = offsets[direction];
        const nextRoom = rooms.find(r => 
          r.x === currentRoom.x + offset.dx && 
          r.y === currentRoom.y + offset.dy
        );
        return nextRoom && nextRoom.type === ROOM_TYPES.TREASURE;
      }

      const doorSize = 60;
      const canLeave = enemies.length === 0;
      const doorColor = canLeave ? '#00ff00' : '#ff0000';
      
      if (currentRoom.doors.north) {
        const isBossDoor = doorLeadsToBoss('north');
        const isTreasureDoor = doorLeadsToTreasure('north');
        if (isBossDoor) {
          ctx.shadowBlur = 20 + Math.sin(Date.now() / 200) * 10;
          ctx.shadowColor = '#ff00ff';
          ctx.fillStyle = '#ff00ff';
          ctx.fillRect(ROOM_WIDTH / 2 - doorSize / 2, 0, doorSize, 10);
          ctx.fillStyle = '#fff';
          ctx.font = 'bold 16px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('â˜ ', ROOM_WIDTH / 2, 25);
          ctx.shadowBlur = 0;
        } else if (isTreasureDoor) {
          ctx.shadowBlur = 15;
          ctx.shadowColor = '#ffaa00';
          ctx.fillStyle = '#ffaa00';
          ctx.fillRect(ROOM_WIDTH / 2 - doorSize / 2, 0, doorSize, 10);
          ctx.fillStyle = '#fff';
          ctx.font = 'bold 16px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('â—†', ROOM_WIDTH / 2, 25);
          ctx.shadowBlur = 0;
        } else {
          ctx.fillStyle = doorColor;
          ctx.fillRect(ROOM_WIDTH / 2 - doorSize / 2, 0, doorSize, 10);
        }
      }
      
      if (currentRoom.doors.south) {
        const isBossDoor = doorLeadsToBoss('south');
        const isTreasureDoor = doorLeadsToTreasure('south');
        if (isBossDoor) {
          ctx.shadowBlur = 20 + Math.sin(Date.now() / 200) * 10;
          ctx.shadowColor = '#ff00ff';
          ctx.fillStyle = '#ff00ff';
          ctx.fillRect(ROOM_WIDTH / 2 - doorSize / 2, ROOM_HEIGHT - 10, doorSize, 10);
          ctx.fillStyle = '#fff';
          ctx.font = 'bold 16px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('â˜ ', ROOM_WIDTH / 2, ROOM_HEIGHT - 15);
          ctx.shadowBlur = 0;
        } else if (isTreasureDoor) {
          ctx.shadowBlur = 15;
          ctx.shadowColor = '#ffaa00';
          ctx.fillStyle = '#ffaa00';
          ctx.fillRect(ROOM_WIDTH / 2 - doorSize / 2, ROOM_HEIGHT - 10, doorSize, 10);
          ctx.fillStyle = '#fff';
          ctx.font = 'bold 16px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('â—†', ROOM_WIDTH / 2, ROOM_HEIGHT - 15);
          ctx.shadowBlur = 0;
        } else {
          ctx.fillStyle = doorColor;
          ctx.fillRect(ROOM_WIDTH / 2 - doorSize / 2, ROOM_HEIGHT - 10, doorSize, 10);
        }
      }
      
      if (currentRoom.doors.east) {
        const isBossDoor = doorLeadsToBoss('east');
        const isTreasureDoor = doorLeadsToTreasure('east');
        if (isBossDoor) {
          ctx.shadowBlur = 20 + Math.sin(Date.now() / 200) * 10;
          ctx.shadowColor = '#ff00ff';
          ctx.fillStyle = '#ff00ff';
          ctx.fillRect(ROOM_WIDTH - 10, ROOM_HEIGHT / 2 - doorSize / 2, 10, doorSize);
          ctx.fillStyle = '#fff';
          ctx.font = 'bold 16px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('â˜ ', ROOM_WIDTH - 25, ROOM_HEIGHT / 2 + 5);
          ctx.shadowBlur = 0;
        } else if (isTreasureDoor) {
          ctx.shadowBlur = 15;
          ctx.shadowColor = '#ffaa00';
          ctx.fillStyle = '#ffaa00';
          ctx.fillRect(ROOM_WIDTH - 10, ROOM_HEIGHT / 2 - doorSize / 2, 10, doorSize);
          ctx.fillStyle = '#fff';
          ctx.font = 'bold 16px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('ï¿½ï¿½ï¿½', ROOM_WIDTH - 25, ROOM_HEIGHT / 2 + 5);
          ctx.shadowBlur = 0;
        } else {
          ctx.fillStyle = doorColor;
          ctx.fillRect(ROOM_WIDTH - 10, ROOM_HEIGHT / 2 - doorSize / 2, 10, doorSize);
        }
      }
      
      if (currentRoom.doors.west) {
        const isBossDoor = doorLeadsToBoss('west');
        const isTreasureDoor = doorLeadsToTreasure('west');
        if (isBossDoor) {
          ctx.shadowBlur = 20 + Math.sin(Date.now() / 200) * 10;
          ctx.shadowColor = '#ff00ff';
          ctx.fillStyle = '#ff00ff';
          ctx.fillRect(0, ROOM_HEIGHT / 2 - doorSize / 2, 10, doorSize);
          ctx.fillStyle = '#fff';
          ctx.font = 'bold 16px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('â˜ ', 25, ROOM_HEIGHT / 2 + 5);
          ctx.shadowBlur = 0;
        } else if (isTreasureDoor) {
          ctx.shadowBlur = 15;
          ctx.shadowColor = '#ffaa00';
          ctx.fillStyle = '#ffaa00';
          ctx.fillRect(0, ROOM_HEIGHT / 2 - doorSize / 2, 10, doorSize);
          ctx.fillStyle = '#fff';
          ctx.font = 'bold 16px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('â—†', 25, ROOM_HEIGHT / 2 + 5);
          ctx.shadowBlur = 0;
        } else {
          ctx.fillStyle = doorColor;
          ctx.fillRect(0, ROOM_HEIGHT / 2 - doorSize / 2, 10, doorSize);
        }
      }

      if (currentRoom.type === ROOM_TYPES.BOSS) {
        ctx.fillStyle = 'rgba(255, 0, 255, 0.1)';
        ctx.fillRect(0, 0, ROOM_WIDTH, ROOM_HEIGHT);
      } else if (currentRoom.type === ROOM_TYPES.TREASURE) {
        ctx.fillStyle = 'rgba(255, 170, 0, 0.05)';
        ctx.fillRect(0, 0, ROOM_WIDTH, ROOM_HEIGHT);
      }
    }

    function drawMinimap() {
      minimapCtx.fillStyle = '#000';
      minimapCtx.fillRect(0, 0, 150, 150);

      const scale = 15;
      const offsetX = 75;
      const offsetY = 75;

      rooms.forEach(room => {
        const x = offsetX + room.x * scale;
        const y = offsetY + room.y * scale;

        // Nerd passive: reveal treasure and boss rooms even if not visited
        const shouldReveal = room.visited || (hasNerd && (room.type === ROOM_TYPES.BOSS || room.type === ROOM_TYPES.TREASURE));

        if (shouldReveal) {
          minimapCtx.fillStyle = room === currentRoom ? '#00ff00' : 
                                 room.type === ROOM_TYPES.BOSS ? '#ff00ff' : 
                                 room.type === ROOM_TYPES.TREASURE ? '#ffaa00' :
                                 room.cleared ? '#666' : '#ff0000';
        } else {
          minimapCtx.fillStyle = '#333';
        }

        minimapCtx.fillRect(x - 5, y - 5, 10, 10);
        
        // Nerd passive: add icons for revealed special rooms
        if (hasNerd && !room.visited) {
          if (room.type === ROOM_TYPES.BOSS) {
            minimapCtx.fillStyle = '#fff';
            minimapCtx.font = 'bold 10px Arial';
            minimapCtx.textAlign = 'center';
            minimapCtx.textBaseline = 'middle';
            minimapCtx.fillText('â˜ ', x, y);
          } else if (room.type === ROOM_TYPES.TREASURE) {
            minimapCtx.fillStyle = '#fff';
            minimapCtx.font = 'bold 10px Arial';
            minimapCtx.textAlign = 'center';
            minimapCtx.textBaseline = 'middle';
            minimapCtx.fillText('â—†', x, y);
          }
        }

        if (room.visited) {
          minimapCtx.strokeStyle = '#888';
          minimapCtx.lineWidth = 2;
          if (room.doors.north) {
            minimapCtx.beginPath();
            minimapCtx.moveTo(x, y - 5);
            minimapCtx.lineTo(x, y - scale / 2);
            minimapCtx.stroke();
          }
          if (room.doors.south) {
            minimapCtx.beginPath();
            minimapCtx.moveTo(x, y + 5);
            minimapCtx.lineTo(x, y + scale / 2);
            minimapCtx.stroke();
          }
          if (room.doors.east) {
            minimapCtx.beginPath();
            minimapCtx.moveTo(x + 5, y);
            minimapCtx.lineTo(x + scale / 2, y);
            minimapCtx.stroke();
          }
          if (room.doors.west) {
            minimapCtx.beginPath();
            minimapCtx.moveTo(x - 5, y);
            minimapCtx.lineTo(x - scale / 2, y);
            minimapCtx.stroke();
          }
        }
      });
    }

    function draw() {
      ctx.fillStyle = '#0a0a0a';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      if (gameState !== 'playing') return;

      ctx.save();
      const offsetX = (canvas.width - ROOM_WIDTH) / 2;
      const offsetY = (canvas.height - ROOM_HEIGHT) / 2;
      ctx.translate(offsetX, offsetY);

      drawRoom();
      particles.forEach(p => p.draw());
      coins.forEach(c => c.draw());
      if (weaponPickup) {
        weaponPickup.draw();
      }
      bullets.forEach(b => b.draw());
      enemies.forEach(e => e.draw());
      if (player) {
        player.draw();
      }
      if (hasDog && dog) {
        dog.draw();
      }

      ctx.restore();

      drawMinimap();
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    function updateUI() {
      document.getElementById('floor-display').textContent = currentFloor;
      document.getElementById('kills-display').textContent = totalKills;
      document.getElementById('coins-display').textContent = totalCoins;
      const healthPercent = (player.health / player.maxHealth) * 100;
      document.getElementById('health-fill').style.width = healthPercent + '%';
    }

    function showGameOver() {
      document.getElementById('final-floor').textContent = currentFloor;
      document.getElementById('final-kills').textContent = totalKills;
      document.getElementById('final-coins').textContent = totalCoins;
      document.getElementById('game-over-screen').classList.remove('hidden');
    }

    function showVictory() {
      document.getElementById('next-floor').textContent = currentFloor + 1;
      document.getElementById('victory-screen').classList.remove('hidden');
    }

    function openShop() {
      document.getElementById('shop-coins-display').textContent = totalCoins;
      generateShopItems();
      document.getElementById('shop-screen').classList.remove('hidden');
      updateShopButtons();
    }

    function generateShopItems() {
      const weaponToId = new Map([
        [WEAPONS.AUTOBLASTER, 'autoblaster'],
        [WEAPONS.SHOTGUN, 'shotgun'],
        [WEAPONS.CANNON, 'cannon'],
        [WEAPONS.BAZOOKA, 'bazooka'],
        [WEAPONS.SNIPER, 'sniper'],
        [WEAPONS.MINIGUN, 'minigun'],
        [WEAPONS.FLAMETHROWER, 'flamethrower'],
        [WEAPONS.ROCKET, 'rocket'],
        [WEAPONS.TASER, 'taser']
      ]);
      
      const currentWeaponId = weaponToId.get(player.weapon);
      
      const allItems = [
        { id: 'health', icon: 'â¤ï¸', name: 'Health Potion', desc: 'Restore 50 HP', price: 9 },
        { id: 'maxhealth', icon: 'ðŸ’ª', name: 'Max Health +20', desc: 'Permanent HP boost', price: 15 },
        { id: 'speed', icon: 'âš¡', name: 'Speed Boost', desc: '+15% move speed', price: 12 },
        { id: 'damage', icon: 'âš”ï¸', name: 'Damage +20%', desc: 'All weapons stronger', price: 18 },
        { id: 'firerate', icon: 'â±ï¸', name: 'Fire Rate +15%', desc: 'Faster shooting', price: 15 },
        { id: 'dash', icon: 'ðŸ’¨', name: 'Better Dash', desc: 'Shorter cooldown', price: 12 }
      ];

      // Add weapons (only if not currently equipped)
      const weaponItems = [
        { id: 'autoblaster', icon: 'ðŸ”«', name: 'Auto Blaster', desc: 'Fast fire rate', price: 11 },
        { id: 'shotgun', icon: 'ðŸ’¥', name: 'Shotgun', desc: '8 pellets spread', price: 13 },
        { id: 'cannon', icon: 'ðŸŽ¯', name: 'Cannon', desc: 'Heavy damage', price: 14 },
        { id: 'bazooka', icon: 'ðŸ’£', name: 'Bazooka', desc: '3 shot burst', price: 14 },
        { id: 'sniper', icon: 'ï¿½ï¿½ï¿½ï¿½', name: 'Sniper Rifle', desc: 'Long range power', price: 15 },
        { id: 'minigun', icon: 'âš™ï¸', name: 'Minigun', desc: 'Hold down to unleash!', price: 13 },
        { id: 'flamethrower', icon: 'ðŸ”¥', name: 'Flamethrower', desc: 'Continuous fire spray', price: 16 },
        { id: 'rocket', icon: 'ðŸš€', name: 'Rocket Launcher', desc: 'Explosive splash damage', price: 18 },
        { id: 'taser', icon: 'âš¡', name: 'Taser', desc: 'Stuns enemies!', price: 14 },
        { id: 'bouncer', icon: 'ðŸ”µ', name: 'Bouncer', desc: 'Bounces between 3 enemies!', price: 17 },
        { id: 'homing', icon: 'ðŸŽ¯', name: 'Homing Missiles', desc: 'Auto-tracks enemies!', price: 19 }
      ];
      
      weaponItems.forEach(weapon => {
        if (weapon.id !== currentWeaponId) {
          allItems.push(weapon);
        }
      });

      // Add passive items (only if not already owned)
      if (!hasHotshot) {
        allItems.push({ id: 'hotshot', icon: 'ðŸ”¥', name: 'HOTSHOT', desc: 'Enemies burn on hit! (Unique)', price: 35 });
      }
      if (!hasVampire) {
        allItems.push({ id: 'vampire', icon: 'ðŸ§›', name: 'VAMPIRE', desc: 'Lifesteal on kill! (Unique)', price: 35 });
      }
      if (!hasSugarRush) {
        allItems.push({ id: 'sugarrush', icon: 'ðŸ­', name: 'SUGAR RUSH', desc: 'Speed up on hits, reset on miss! (Unique)', price: 35 });
      }
      if (!hasPennyPincher) {
        allItems.push({ id: 'pennypincher', icon: 'ðŸŽ©', name: 'PENNY PINCHER', desc: '2x coins from enemies! (Unique)', price: 35 });
      }
      if (!hasMirror) {
        allItems.push({ id: 'mirror', icon: 'ðŸªž', name: 'MIRROR', desc: 'Every 10th shot fires all directions! (Unique)', price: 35 });
      }
      if (!hasBrassKnuckles) {
        allItems.push({ id: 'brassknuckles', icon: 'ðŸ‘Š', name: 'BRASS KNUCKLES', desc: 'Punch kills boost damage! (Unique)', price: 30 });
      }
      if (!hasKaboom) {
        allItems.push({ id: 'kaboom', icon: 'ðŸ’¥', name: 'KABOOM', desc: 'All bullets explode on impact! (Unique)', price: 30 });
      }
      if (!hasNerd) {
        allItems.push({ id: 'nerd', icon: 'ðŸ¤“', name: 'NERD', desc: 'See treasure & boss rooms on map! (Unique)', price: 30 });
      }
      if (!hasComeback) {
        allItems.push({ id: 'comeback', icon: 'ðŸŒˆ', name: 'COMEBACK', desc: '+50% damage, +100% speed, better dash & fire rate at <25% HP! (Unique)', price: 35 });
      }
      if (!hasDog) {
        allItems.push({ id: 'dog', icon: 'ðŸ•', name: 'DOG', desc: 'Loyal companion attacks enemies! (Unique)', price: 30 });
      }
      if (!hasHalo) {
        allItems.push({ id: 'halo', icon: 'ðŸ˜‡', name: 'HALO', desc: 'Every 4 enemy rooms auto-clear! (Unique)', price: 30 });
      }

      // Shuffle and pick 6 random items
      const shuffled = allItems.sort(() => Math.random() - 0.5);
      const selectedItems = shuffled.slice(0, 6);

      const shopItemsContainer = document.getElementById('shop-items');
      shopItemsContainer.innerHTML = '';

      selectedItems.forEach(item => {
        const itemDiv = document.createElement('div');
        itemDiv.className = 'shop-item';
        itemDiv.innerHTML = `
          <div class="shop-item-icon">${item.icon}</div>
          <div class="shop-item-name">${item.name}</div>
          <div class="shop-item-desc">${item.desc}</div>
          <div class="shop-item-price">ðŸ’° ${item.price}</div>
          <button class="shop-buy-btn" data-item="${item.id}">BUY</button>
        `;
        shopItemsContainer.appendChild(itemDiv);
      });

      // Re-attach event listeners to new buttons
      document.querySelectorAll('.shop-buy-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          buyItem(btn.dataset.item);
        });
      });
    }

    function updateShopButtons() {
      const costs = {
        health: 9, maxhealth: 15, speed: 12,
        autoblaster: 11, shotgun: 13, cannon: 14,
        bazooka: 14, sniper: 15, minigun: 13,
        flamethrower: 16, rocket: 18, taser: 14,
        bouncer: 17, homing: 19,
        damage: 18, firerate: 15, dash: 12,
        hotshot: 35, vampire: 35, sugarrush: 35, pennypincher: 35,
        mirror: 35, brassknuckles: 30, kaboom: 30, nerd: 30, comeback: 35,
        dog: 30, halo: 30
      };

      const buttons = document.querySelectorAll('.shop-buy-btn');
      buttons.forEach(btn => {
        const item = btn.dataset.item;
        const cost = costs[item] || 0;
        btn.disabled = totalCoins < cost;
      });

      // Update reroll button
      const rerollBtn = document.getElementById('reroll-shop-btn');
      if (rerollBtn) {
        rerollBtn.disabled = totalCoins < 5;
      }
    }

    function buyItem(item) {
      const itemData = {
        health: { cost: 9, action: () => { player.health = Math.min(player.health + 50, player.maxHealth); updateUI(); } },
        maxhealth: { cost: 15, action: () => { player.maxHealth += 20; player.health += 20; updateUI(); } },
        speed: { cost: 12, action: () => { speedBoosts++; player.speed = PLAYER_SPEED + (speedBoosts * 0.6); } },
        autoblaster: { cost: 11, action: () => player.setWeapon(WEAPONS.AUTOBLASTER) },
        shotgun: { cost: 13, action: () => player.setWeapon(WEAPONS.SHOTGUN) },
        cannon: { cost: 14, action: () => player.setWeapon(WEAPONS.CANNON) },
        bazooka: { cost: 14, action: () => player.setWeapon(WEAPONS.BAZOOKA) },
        sniper: { cost: 15, action: () => player.setWeapon(WEAPONS.SNIPER) },
        minigun: { cost: 13, action: () => player.setWeapon(WEAPONS.MINIGUN) },
        flamethrower: { cost: 16, action: () => player.setWeapon(WEAPONS.FLAMETHROWER) },
        rocket: { cost: 18, action: () => player.setWeapon(WEAPONS.ROCKET) },
        taser: { cost: 14, action: () => player.setWeapon(WEAPONS.TASER) },
        bouncer: { cost: 17, action: () => player.setWeapon(WEAPONS.BOUNCER) },
        homing: { cost: 19, action: () => player.setWeapon(WEAPONS.HOMING) },
        damage: { cost: 18, action: () => damageMultiplier += 0.2 },
        firerate: { cost: 15, action: () => fireRateMultiplier *= 0.85 },
        dash: { cost: 12, action: () => dashBoosts++ },
        hotshot: { cost: 35, action: () => { hasHotshot = true; generateShopItems(); } },
        vampire: { cost: 35, action: () => { hasVampire = true; generateShopItems(); } },
        sugarrush: { cost: 35, action: () => { hasSugarRush = true; generateShopItems(); } },
        pennypincher: { cost: 35, action: () => { hasPennyPincher = true; generateShopItems(); } },
        mirror: { cost: 35, action: () => { hasMirror = true; mirrorShotCounter = 0; generateShopItems(); } },
        brassknuckles: { cost: 30, action: () => { hasBrassKnuckles = true; generateShopItems(); } },
        kaboom: { cost: 30, action: () => { hasKaboom = true; generateShopItems(); } },
        nerd: { cost: 30, action: () => { hasNerd = true; generateShopItems(); } },
        comeback: { cost: 35, action: () => { hasComeback = true; generateShopItems(); } },
        dog: { cost: 30, action: () => { hasDog = true; dog = new Dog(); dog.x = player.x; dog.y = player.y; generateShopItems(); } },
        halo: { cost: 30, action: () => { hasHalo = true; generateShopItems(); } }
      };

      const data = itemData[item];
      if (data && totalCoins >= data.cost) {
        data.action();
        totalCoins -= data.cost;
        document.getElementById('shop-coins-display').textContent = totalCoins;
        document.getElementById('coins-display').textContent = totalCoins;
        updateShopButtons();
      }
    }

    document.getElementById('start-btn').addEventListener('click', () => {
      document.getElementById('start-screen').classList.add('hidden');
      gameState = 'playing';
      currentFloor = 1;
      totalKills = 0;
      totalCoins = 0;
      damageMultiplier = 1;
      fireRateMultiplier = 1;
      speedBoosts = 0;
      dashBoosts = 0;
      hasHotshot = false;
      hasVampire = false;
      hasSugarRush = false;
      sugarRushStacks = 0;
      hasPennyPincher = false;
      hasMirror = false;
      mirrorShotCounter = 0;
      hasBrassKnuckles = false;
      brassKnuckleStacks = 0;
      hasKaboom = false;
      hasNerd = false;
      hasComeback = false;
      hasDog = false;
      dog = null;
      hasHalo = false;
      haloRoomCounter = 0;
      initGame();
      startRoom();
    });

    document.getElementById('restart-btn').addEventListener('click', () => {
      document.getElementById('game-over-screen').classList.add('hidden');
      gameState = 'playing';
      currentFloor = 1;
      totalKills = 0;
      totalCoins = 0;
      damageMultiplier = 1;
      fireRateMultiplier = 1;
      speedBoosts = 0;
      dashBoosts = 0;
      hasHotshot = false;
      hasVampire = false;
      hasSugarRush = false;
      sugarRushStacks = 0;
      hasPennyPincher = false;
      hasMirror = false;
      mirrorShotCounter = 0;
      hasBrassKnuckles = false;
      brassKnuckleStacks = 0;
      hasKaboom = false;
      hasNerd = false;
      hasComeback = false;
      hasDog = false;
      dog = null;
      hasHalo = false;
      haloRoomCounter = 0;
      initGame();
      startRoom();
    });

    document.getElementById('continue-btn').addEventListener('click', () => {
      document.getElementById('victory-screen').classList.add('hidden');
      openShop();
    });

    document.getElementById('reroll-shop-btn').addEventListener('click', () => {
      const rerollCost = 5;
      if (totalCoins >= rerollCost) {
        totalCoins -= rerollCost;
        document.getElementById('shop-coins-display').textContent = totalCoins;
        document.getElementById('coins-display').textContent = totalCoins;
        generateShopItems();
        updateShopButtons();
      }
    });

    document.getElementById('leave-shop-btn').addEventListener('click', () => {
      document.getElementById('shop-screen').classList.add('hidden');
      gameState = 'playing';
      currentFloor++;
      const savedWeapon = player.weapon;
      const savedHealth = player.health;
      
      // Reset brass knuckles stacks on new floor
      brassKnuckleStacks = 0;
      
      initGame();
      player.health = Math.min(savedHealth + 35, player.maxHealth);
      player.weapon = savedWeapon;
      player.speed = PLAYER_SPEED + (speedBoosts * 0.6);
      document.getElementById('weapon-display').textContent = savedWeapon.name;
      
      // Restore dog if player has one
      if (hasDog) {
        dog = new Dog();
        dog.x = player.x;
        dog.y = player.y;
      }
      
      updateUI();
      startRoom();
    });

    window.addEventListener('keydown', (e) => {
      keys[e.key] = true;
      
      // Konami code detection
      if (e.key === konamiCode[konamiProgress]) {
        konamiProgress++;
        if (konamiProgress === konamiCode.length) {
          // Konami code completed!
          totalCoins += 1000;
          updateUI();
          document.getElementById('shop-coins-display').textContent = totalCoins;
          konamiProgress = 0;
          
          // Visual celebration
          for (let i = 0; i < 100; i++) {
            const x = Math.random() * ROOM_WIDTH;
            const y = Math.random() * ROOM_HEIGHT;
            particles.push(new Particle(x, y, '#ffd700'));
          }
          
          // Show message
          const celebrationMsg = document.createElement('div');
          celebrationMsg.textContent = 'ðŸŽ® KONAMI CODE! +1000 COINS! ðŸŽ®';
          celebrationMsg.style.position = 'fixed';
          celebrationMsg.style.top = '50%';
          celebrationMsg.style.left = '50%';
          celebrationMsg.style.transform = 'translate(-50%, -50%)';
          celebrationMsg.style.fontSize = '48px';
          celebrationMsg.style.color = '#ffd700';
          celebrationMsg.style.fontWeight = 'bold';
          celebrationMsg.style.textShadow = '0 0 30px #ffd700';
          celebrationMsg.style.zIndex = '1000';
          celebrationMsg.style.pointerEvents = 'none';
          celebrationMsg.style.fontFamily = "'Courier New', monospace";
          document.body.appendChild(celebrationMsg);
          
          setTimeout(() => {
            celebrationMsg.remove();
          }, 3000);
        }
      } else {
        konamiProgress = 0;
      }
      
      if (e.key === ' ' || e.key === 'Spacebar') {
        e.preventDefault();
        if (gameState === 'playing') player.dash();
      }
      if (e.key === 'f' || e.key === 'F') {
        e.preventDefault();
        if (gameState === 'playing') player.punch(mouse.x, mouse.y);
      }
    });

    window.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    document.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const offsetX = (canvas.width - ROOM_WIDTH) / 2;
      const offsetY = (canvas.height - ROOM_HEIGHT) / 2;
      mouse.x = e.clientX - rect.left - offsetX;
      mouse.y = e.clientY - rect.top - offsetY;
    });

    let mouseDown = false;

    document.addEventListener('mousedown', (e) => {
      mouseDown = true;
    });

    document.addEventListener('mouseup', (e) => {
      mouseDown = false;
    });

    document.addEventListener('click', (e) => {
      if (gameState === 'playing') {
        const rect = canvas.getBoundingClientRect();
        const offsetX = (canvas.width - ROOM_WIDTH) / 2;
        const offsetY = (canvas.height - ROOM_HEIGHT) / 2;
        const targetX = e.clientX - rect.left - offsetX;
        const targetY = e.clientY - rect.top - offsetY;
        player.shoot(targetX, targetY);
      }
    });

    gameLoop();
  </script>
 <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9afaf4beb7aec307',t:'MTc2NjAyMjA2Ny4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>


